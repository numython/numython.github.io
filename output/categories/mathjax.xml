<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Numython (mathjax)</title><link>https://numython.github.io/</link><description></description><atom:link href="https://numython.github.io/categories/mathjax.xml" type="application/rss+xml" rel="self"></atom:link><language>es</language><lastBuildDate>Tue, 18 Oct 2016 16:00:37 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>NumPy para usuarios de MATLAB</title><link>https://numython.github.io/posts/numpy-para-usuarios-de-matlab/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div&gt;&lt;p&gt;# NumPy para usuarios de MATLAB&lt;/p&gt;
&lt;p&gt;Esta es una traducción/adaptación de [Numpy for Matlab users](&lt;a class="reference external" href="https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html"&gt;https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;### Introducción&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- MATLAB® and NumPy/SciPy have a lot in common. But there are many differences. NumPy and SciPy were created to do numerical and scientific computing in the most natural way with Python, not to be MATLAB® clones. This page is intended to be a place to collect wisdom about the differences, mostly for the purpose of helping proficient MATLAB® users become proficient NumPy and SciPy users. --&amp;gt;&lt;/p&gt;
&lt;p&gt;MATLAB y NumPy/SciPy tienen mucho en común. Pero hay muchas diferencias. NumPy y SciPy fueron creados para
&lt;em&gt;hacer&lt;/em&gt; computación científica y numérica de manera más natural con Python, no como un clon de MATLAB.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- ### Some Key Differences --&amp;gt;
### Algunas diferencias fundamentales&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- In MATLAB®, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra. --&amp;gt;&lt;/p&gt;
&lt;p&gt;En MATLAB, el tipo de dato básico es un array multidimensional de precisión doble. La mayoría de las expresiones
toman un array y devuelven justamente el mismo tipo de dato. Las operaciones de arrays bidimensionales están
diseñadas para actuar más o menos como las operaciones matriciales del álgebra lineal.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- In NumPy the basic type is a multidimensional array. Operations on these arrays in all dimensionalities including 2D are elementwise operations. However, there is a special matrix type for doing linear algebra, which is just a subclass of the array class. Operations on matrix-class arrays are linear algebra operations. --&amp;gt;&lt;/p&gt;
&lt;p&gt;En NumPy el tipo básico es un array multidimensional. Las operaciones en estos arrays en todas sus dimensiones,
incluyendo 2D, son operaciones elemento a elemento. Sin embargo, hay un tipo &lt;cite&gt;matrix&lt;/cite&gt; especial para hacer
operaciones de álgebra lineal, el cual es justamente una subclase de la clase &lt;cite&gt;array&lt;/cite&gt;. Las operaciones
en la clase &lt;cite&gt;matrix&lt;/cite&gt; son operaciones de álgebra lineal.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- MATLAB® uses 1 (one) based indexing. The initial element of a sequence is found using a(1). See note INDEXING   --&amp;gt;&lt;/p&gt;
&lt;p&gt;MATLAB utiliza indexación basada en 1 (uno). El elemento inicial de la secuencia A se obtiene usando A(1).&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Python uses 0 (zero) based indexing. The initial element of a sequence is found using a[0]. --&amp;gt;&lt;/p&gt;
&lt;p&gt;Python utiliza indexación basada en 0 (cero). El elemento inicial de la secuencia A se obtiene usando A[0].&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- MATLAB®’s scripting language was created for doing linear algebra. The syntax for basic matrix operations is nice and clean, but the API for adding GUIs and making full-fledged applications is more or less an afterthought.  --&amp;gt;&lt;/p&gt;
&lt;p&gt;El lenguaje de scripting MATLAB fue creado para &lt;em&gt;hacer&lt;/em&gt; algebra lineal. La sintaxis para la mayoría de las operaciones
matriciales básicas es buena y clara, pero la API para agregar una interfaz gráfica y hacer &lt;em&gt;aplicaciones de verdad&lt;/em&gt;
es más o menos una idea adicionada posteriormente y cuya integración es poco fluida.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab’s syntax for some array manipulations is more compact than NumPy’s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance subclassing the main array type to do both array and matrix math cleanly. --&amp;gt;&lt;/p&gt;
&lt;p&gt;NumPy está basado en Python, el cuál fue diseñado desde un inicio para ser un excelente lenguaje de programación
de propósito general. Mientras la sintaxis de MATLAB para algunas manipulaciones de arrays es más compacta
que la de NumPy, NumPy puede hacer muchas cosas que en MATLAB son imposibles, por ejemplo heredar desde el
principal tipo de array (clase &lt;cite&gt;np.ndarray&lt;/cite&gt;) para hacer un tipo &lt;cite&gt;matrix&lt;/cite&gt; que sea más claro para realizar
operaciones de álgebra lineal.&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- In MATLAB®, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array.     --&amp;gt;&lt;/p&gt;
&lt;p&gt;En MATLAB, los arrays tiene&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array. --&amp;gt;&lt;/p&gt;
&lt;p&gt;En NumPy, los arrays&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- ### ‘array’ or ‘matrix’? Which should I use? --&amp;gt;&lt;/p&gt;
&lt;p&gt;### ¿&lt;cite&gt;array&lt;/cite&gt; o &lt;cite&gt;matrix&lt;/cite&gt;? ¿Cuál debería utilizar?&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Numpy provides, in addition to np.ndarray` an additional matrix type that you may see used in some existing code. Which one to use? --&amp;gt;&lt;/p&gt;
&lt;p&gt;NumPy proporciona adicionalmente a &lt;cite&gt;np.ndarray&lt;/cite&gt; un tipo &lt;cite&gt;matrix&lt;/cite&gt;, que puede utilizarse en algunas situaciones
¿Cuál debo usar?&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- #### Short answer --&amp;gt;&lt;/p&gt;
&lt;p&gt;#### Respuesta corta&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- &lt;strong&gt;Use arrays&lt;/strong&gt; --&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Usar el tipo `array`&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- They are the standard vector/matrix/tensor type of numpy. Many numpy function return arrays, not matrices.
There is a clear distinction between element-wise operations and linear algebra operations.
You can have standard vectors or row/column vectors if you like. --&amp;gt;
&amp;lt;!-- The only disadvantage of using the array type is that you will have to use dot instead of * to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). --&amp;gt;
* Es el tipo de matriz/vector estándar de NumPy. Muchas funciones de NumPy devuelven un array, no matrices.
* Hay una distinción clara entre las operaciones elemento a elemento y las de álgebra lineal.
* Puede tener vectores estándar o vectores filas/columnas si lo requiere.&lt;/p&gt;
&lt;p&gt;La única desventaja de usar el tipo array es que tendrás que utilizar la función/método &lt;cite&gt;dot&lt;/cite&gt; en lugar de &lt;cite&gt;*&lt;/cite&gt; para
multiplicar dos tensores (producto escalar, multiplicación matricial,...)&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- #### Long answer --&amp;gt;&lt;/p&gt;
&lt;p&gt;#### Respuesta larga&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Numpy contains both an array class and a matrix class. The array class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while matrix is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two. --&amp;gt;&lt;/p&gt;
&lt;p&gt;NumPy contiene una clase &lt;cite&gt;array&lt;/cite&gt; y una clase &lt;cite&gt;matrix&lt;/cite&gt;. La clase &lt;cite&gt;array&lt;/cite&gt; tiene la finalidad de ser un
array n-dimensional de propósito general para muchos tipos de computación numérica, mientras la
clase &lt;cite&gt;matrix&lt;/cite&gt; tiene la finalidad de facilitar especificamente cuestiones relacionadas con la
computación del álgebra lineal. En la práctica, sólo hay un puñado de diferencias claves
entre ambas:&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- Operator &lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id1"&gt;&lt;span class="problematic" id="id2"&gt;*&lt;/span&gt;&lt;/a&gt;, dot(), and multiply():
For array, ‘&lt;tt class="docutils literal"&gt;*&lt;/tt&gt;’ means element-wise multiplication, and the dot() function is used for matrix multiplication.
For matrix, ‘&lt;tt class="docutils literal"&gt;*&lt;/tt&gt;’ means matrix multiplication, and the multiply() function is used for element-wise multiplication. --&amp;gt;&lt;/p&gt;
&lt;div class="system-message" id="id1"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 98); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id2"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline emphasis start-string without end-string.&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;&lt;dl class="first docutils"&gt;
&lt;dt&gt;Operator &lt;cite&gt;*&lt;/cite&gt;, &lt;cite&gt;dot()&lt;/cite&gt;, and &lt;cite&gt;multiply()&lt;/cite&gt;:&lt;/dt&gt;
&lt;dd&gt;&lt;ul class="first last simple"&gt;
&lt;li&gt;Para array ---&lt;/li&gt;
&lt;li&gt;Para matrix&lt;/li&gt;
&lt;/ul&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Handling of vectors (rank-1 arrays)
For array, the vector shapes 1xN, Nx1, and N are all different things. Operations like A[:,1] return a rank-1 array of shape N, not a rank-2 of shape Nx1. Transpose on a rank-1 array does nothing.
For matrix, rank-1 arrays are always upconverted to 1xN or Nx1 matrices (row or column vectors). A[:,1] returns a rank-2 matrix of shape Nx1.
Handling of higher-rank arrays (rank &amp;gt; 2)
array objects can have rank &amp;gt; 2.
matrix objects always have exactly rank 2.
Convenience attributes
array has a .T attribute, which returns the transpose of the data.
matrix also has .H, .I, and .A attributes, which return the conjugate transpose, inverse, and asarray() of the matrix, respectively.
Convenience constructor
The array constructor takes (nested) Python sequences as initializers. As in, array([[1,2,3],[4,5,6]]).
The matrix constructor additionally takes a convenient string initializer. As in matrix("[1 2 3; 4 5 6]").
There are pros and cons to using both:&lt;/p&gt;
&lt;p&gt;array
:) You can treat rank-1 arrays as either row or column vectors. dot(A,v) treats v as a column vector, while dot(v,A) treats v as a row vector. This can save you having to type a lot of transposes.
&amp;lt;:( Having to use the dot() function for matrix-multiply is messy – dot(dot(A,B),C) vs. A*B*C.
:) Element-wise multiplication is easy: A*B.
:) array is the “default” NumPy type, so it gets the most testing, and is the type most likely to be returned by 3rd party code that uses NumPy.
:) Is quite at home handling data of any rank.
:) Closer in semantics to tensor algebra, if you are familiar with that.
:) All operations (&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id3"&gt;&lt;span class="problematic" id="id4"&gt;*&lt;/span&gt;&lt;/a&gt;, /, +, &lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id5"&gt;&lt;span class="problematic" id="id6"&gt;``&lt;/span&gt;&lt;/a&gt;`` etc.) are elementwise
matrix
:\ Behavior is more like that of MATLAB® matrices.
&amp;lt;:( Maximum of rank-2. To hold rank-3 data you need array or perhaps a Python list of matrix.
&amp;lt;:( Minimum of rank-2. You cannot have vectors. They must be cast as single-column or single-row matrices.
&amp;lt;:( Since array is the default in NumPy, some functions may return an array even if you give them a matrix as an argument. This shouldn’t happen with NumPy functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor type preservation like NumPy does.
:) A*B is matrix multiplication, so more convenient for linear algebra.
&amp;lt;:( Element-wise multiplication requires calling a function, multipy(A,B).
&amp;lt;:( The use of operator overloading is a bit illogical: * does not work elementwise but / does.
The array is thus much more advisable to use.&lt;/p&gt;
&lt;div class="system-message" id="id3"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 120); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id4"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline emphasis start-string without end-string.&lt;/div&gt;
&lt;div class="system-message" id="id5"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 120); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id6"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline literal start-string without end-string.&lt;/div&gt;
&lt;p&gt;### Facilities for Matrix Users
Numpy has some features that facilitate the use of the matrix type, which hopefully make things easier for Matlab converts.&lt;/p&gt;
&lt;p&gt;A matlib module has been added that contains matrix versions of common array constructors like ones(), zeros(), empty(), eye(), rand(), repmat(), etc. Normally these functions return arrays, but the matlib versions return matrix objects.
mat has been changed to be a synonym for asmatrix, rather than matrix, thus making it concise way to convert an array to a matrix without copying the data.
Some top-level functions have been removed. For example numpy.rand() now needs to be accessed as numpy.random.rand(). Or use the rand() from the matlib module. But the “numpythonic” way is to use numpy.random.random(), which takes a tuple for the shape, like other numpy functions.
Table of Rough MATLAB-NumPy Equivalents
The table below gives rough equivalents for some common MATLAB® expressions. These are not exact equivalents, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.&lt;/p&gt;
&lt;p&gt;Some care is necessary when writing functions that take arrays or matrices as arguments — if you are expecting an array and are given a matrix, or vice versa, then ‘*’ (multiplication) will give you unexpected results. You can convert back and forth between arrays and matrices using&lt;/p&gt;
&lt;p&gt;asarray: always returns an object of type array
asmatrix or mat: always return an object of type matrix
asanyarray: always returns an array object or a subclass derived from it, depending on the input. For instance if you pass in a matrix it returns a matrix.
These functions all accept both arrays and matrices (among other things like Python lists), and thus are useful when writing functions that should accept any array-like object.&lt;/p&gt;
&lt;p&gt;In the table below, it is assumed that you have executed the following commands in Python:&lt;/p&gt;
&lt;p&gt;from numpy import *
import scipy.linalg
Also assume below that if the Notes talk about “matrix” that the arguments are rank 2 entities.&lt;/p&gt;
&lt;p&gt;General Purpose Equivalents&lt;/p&gt;
&lt;p&gt;MATLAB  numpy   Notes
help func   info(func) or help(func) or func? (in Ipython)  get help on the function func
which func  see note HELP   find out where func is defined
type func   source(func) or func?? (in Ipython) print source for func (if not a native function)
a &amp;amp;&amp;amp; b  a and b short-circuiting logical AND operator (Python native operator); scalar arguments only
a || b  a or b  short-circuiting logical OR operator (Python native operator); scalar arguments only
1*i, 1*j, 1i, 1j    1j  complex numbers
eps np.spacing(1)   Distance between 1 and the nearest floating point number
ode45   scipy.integrate.ode(f).set_integrator('dopri5') integrate an ODE with Runge-Kutta 4,5
ode15s  scipy.integrate.ode(f).set_integrator('vode', method='bdf', order=15)   integrate an ODE with BDF method
Linear Algebra Equivalents&lt;/p&gt;
&lt;p&gt;MATLAB  NumPy   Notes
ndims(a)    ndim(a) or a.ndim   get the number of dimensions of a (tensor rank)
numel(a)    size(a) or a.size   get the number of elements of an array
size(a) shape(a) or a.shape get the “size” of the matrix
size(a,n)   a.shape[n-1]    get the number of elements of the n-th dimension of array a. (Note that MATLAB® uses 1 based indexing while Python uses 0 based indexing, See note INDEXING)
[ 1 2 3; 4 5 6 ]    array([[1.,2.,3.], [4.,5.,6.]]) 2x3 matrix literal
[ a b; c d ]    vstack([hstack([a,b]), hstack([c,d])]) or bmat('a b; c d').A    construct a matrix from blocks a,b,c, and d
a(end)  a[-1]   access last element in the 1xn matrix a
a(2,5)  a[1,4]  access element in second row, fifth column
a(2,:)  a[1] or a[1,:]  entire second row of a
a(1:5,:)    a[0:5] or a[:5] or a[0:5,:] the first five rows of a
a(end-4:end,:)  a[-5:]  the last five rows of a
a(1:3,5:9)  a[0:3][:,4:9]   rows one to three and columns five to nine of a. This gives read-only access.
a([2,4,5],[1,3])    a[ix_([1,3,4],[0,2])]   rows 2,4 and 5 and columns 1 and 3. This allows the matrix to be modified, and doesn’t require a regular slice.
a(3:2:21,:) a[ 2:21:2,:]    every other row of a, starting with the third and going to the twenty-first
a(1:2:end,:)    a[ ::2,:]   every other row of a, starting with the first
a(end:-1:1,:) or flipud(a)  a[ ::-1,:]  a with rows in reverse order
a([1:end 1],:)  a[r_[:len(a),0]]    a with copy of the first row appended to the end
a.' a.transpose() or a.T    transpose of a
a'  a.conj().transpose() or a.conj().T  conjugate transpose of a
a * b   a.dot(b)    matrix multiply
a .* b  a * b   element-wise multiply
a./b    a/b element-wise divide
a.^3    a**3    element-wise exponentiation
(a&amp;gt;0.5) (a&amp;gt;0.5) matrix whose i,jth element is (a_ij &amp;gt; 0.5)
find(a&amp;gt;0.5) nonzero(a&amp;gt;0.5)  find the indices where (a &amp;gt; 0.5)
a(:,find(v&amp;gt;0.5))    a[:,nonzero(v&amp;gt;0.5)[0]]  extract the columms of a where vector v &amp;gt; 0.5
a(:,find(v&amp;gt;0.5))    a[:,v.T&amp;gt;0.5]    extract the columms of a where column vector v &amp;gt; 0.5
a(a&amp;lt;0.5)=0  a[a&amp;lt;0.5]=0  a with elements less than 0.5 zeroed out
a .* (a&amp;gt;0.5)    a * (a&amp;gt;0.5) a with elements less than 0.5 zeroed out
a(:) = 3    a[:] = 3    set all values to the same scalar value
y=x y = x.copy()    numpy assigns by reference
y=x(2,:)    y = x[1,:].copy()   numpy slices are by reference
y=x(:)  y = x.flatten(1)    turn array into vector (note that this forces a copy)
1:10    arange(1.,11.) or r_[1.:11.] or r_[1:10:10j]    create an increasing vector (see note RANGES)
0:9 arange(10.) or r_[:10.] or r_[:9:10j]   create an increasing vector (see note RANGES)
[1:10]' arange(1.,11.)[:, newaxis]  create a column vector
zeros(3,4)  zeros((3,4))    3x4 rank-2 array full of 64-bit floating point zeros
zeros(3,4,5)    zeros((3,4,5))  3x4x5 rank-3 array full of 64-bit floating point zeros
ones(3,4)   ones((3,4)) 3x4 rank-2 array full of 64-bit floating point ones
eye(3)  eye(3)  3x3 identity matrix
diag(a) diag(a) vector of diagonal elements of a
diag(a,0)   diag(a,0)   square diagonal matrix whose nonzero values are the elements of a
rand(3,4)   random.rand(3,4)    random 3x4 matrix
linspace(1,3,4) linspace(1,3,4) 4 equally spaced samples between 1 and 3, inclusive
[x,y]=meshgrid(0:8,0:5) mgrid[0:9.,0:6.] or meshgrid(r_[0:9.],r_[0:6.]  two 2D arrays: one of x values, the other of y values&lt;/p&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 220)&lt;/p&gt;
Unexpected indentation.&lt;/div&gt;
&lt;blockquote&gt;
ogrid[0:9.,0:6.] or ix_(r_[0:9.],r_[0:6.]   the best way to eval functions on a grid&lt;/blockquote&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 221)&lt;/p&gt;
Block quote ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;[x,y]=meshgrid([1,2,4],[2,4,5]) meshgrid([1,2,4],[2,4,5])&lt;/dt&gt;
&lt;dd&gt;ix_([1,2,4],[2,4,5])    the best way to eval functions on a grid&lt;/dd&gt;
&lt;/dl&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 223)&lt;/p&gt;
Definition list ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;repmat(a, m, n) tile(a, (m, n)) create m by n copies of a
[a b]   concatenate((a,b),1) or hstack((a,b)) or column_stack((a,b)) or c_[a,b] concatenate columns of a and b
[a; b]  concatenate((a,b)) or vstack((a,b)) or r_[a,b]  concatenate rows of a and b
max(max(a)) a.max() maximum element of a (with ndims(a)&amp;lt;=2 for matlab)
max(a)  a.max(0)    maximum element of each column of matrix a
max(a,[],2) a.max(1)    maximum element of each row of matrix a
max(a,b)    maximum(a, b)   compares a and b element-wise, and returns the maximum value from each pair
norm(v) sqrt(dot(v,v)) or np.linalg.norm(v) L2 norm of vector v
a &amp;amp; b   logical_and(a,b)    element-by-element AND operator (Numpy ufunc) See note LOGICOPS
a | b   logical_or(a,b) element-by-element OR operator (Numpy ufunc) See note LOGICOPS
bitand(a,b) a &amp;amp; b   bitwise AND operator (Python native and Numpy ufunc)
bitor(a,b)  a | b   bitwise OR operator (Python native and Numpy ufunc)
inv(a)  linalg.inv(a)   inverse of square matrix a
pinv(a) linalg.pinv(a)  pseudo-inverse of matrix a
rank(a) linalg.matrix_rank(a)   rank of a matrix a
ab linalg.solve(a,b) if a is square; linalg.lstsq(a,b) otherwise   solution of a x = b for x
b/a Solve a.T x.T = b.T instead solution of x a = b for x
[U,S,V]=svd(a)  U, S, Vh = linalg.svd(a), V = Vh.T  singular value decomposition of a
chol(a) linalg.cholesky(a).T    cholesky factorization of a matrix (chol(a) in matlab returns an upper triangular matrix, but linalg.cholesky(a) returns a lower triangular matrix)
[V,D]=eig(a)    D,V = linalg.eig(a) eigenvalues and eigenvectors of a
[V,D]=eig(a,b)  V,D = np.linalg.eig(a,b)    eigenvalues and eigenvectors of a,b
[V,D]=eigs(a,k)     find the k largest eigenvalues and eigenvectors of a
[Q,R,P]=qr(a,0) Q,R = scipy.linalg.qr(a)    QR decomposition
[L,U,P]=lu(a)   L,U = scipy.linalg.lu(a) or LU,P=scipy.linalg.lu_factor(a)  LU decomposition (note: P(Matlab) == transpose(P(numpy)) )
conjgrad    scipy.sparse.linalg.cg  Conjugate gradients solver
fft(a)  fft(a)  Fourier transform of a
ifft(a) ifft(a) inverse Fourier transform of a
sort(a) sort(a) or a.sort() sort the matrix
[b,I] = sortrows(a,i)   I = argsort(a[:,i]), b=a[I,:]   sort the rows of the matrix
regress(y,X)    linalg.lstsq(X,y)   multilinear regression
decimate(x, q)  scipy.signal.resample(x, len(x)/q)  downsample with low-pass filtering
unique(a)   unique(a)
squeeze(a)  a.squeeze()
Notes
Submatrix: Assignment to a submatrix can be done with lists of indexes using the &lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id9"&gt;&lt;span class="problematic" id="id10"&gt;ix_&lt;/span&gt;&lt;/a&gt; command. E.g., for 2d array a, one might do: ind=[1,3]; a[np.ix_(ind,ind)]+=100.&lt;/p&gt;
&lt;p&gt;HELP: There is no direct equivalent of MATLAB’s which command, but the commands help and source will usually list the filename where the function is located. Python also has an inspect module (do import inspect) which provides a getfile that often works.&lt;/p&gt;
&lt;p&gt;INDEXING: MATLAB® uses one based indexing, so the initial element of a sequence has index 1. Python uses zero based indexing, so the initial element of a sequence has index 0. Confusion and flamewars arise because each has advantages and disadvantages. One based indexing is consistent with common human language usage, where the “first” element of a sequence has index 1. Zero based indexing simplifies indexing. See also a text by prof.dr. Edsger W. Dijkstra.&lt;/p&gt;
&lt;p&gt;RANGES: In MATLAB®, 0:5 can be used as both a range literal and a ‘slice’ index (inside parentheses); however, in Python, constructs like 0:5 can only be used as a slice index (inside square brackets). Thus the somewhat quirky &lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id11"&gt;&lt;span class="problematic" id="id12"&gt;r_&lt;/span&gt;&lt;/a&gt; object was created to allow numpy to have a similarly terse range construction mechanism. Note that &lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id13"&gt;&lt;span class="problematic" id="id14"&gt;r_&lt;/span&gt;&lt;/a&gt; is not called like a function or a constructor, but rather indexed using square brackets, which allows the use of Python’s slice syntax in the arguments.&lt;/p&gt;
&lt;p&gt;LOGICOPS: &amp;amp; or | in Numpy is bitwise AND/OR, while in Matlab &amp;amp; and | are logical AND/OR. The difference should be clear to anyone with significant programming experience. The two can appear to work the same, but there are important differences. If you would have used Matlab’s &amp;amp; or | operators, you should use the Numpy ufuncs logical_and/logical_or. The notable differences between Matlab’s and Numpy’s &amp;amp; and | operators are:&lt;/p&gt;
&lt;p&gt;Non-logical {0,1} inputs: Numpy’s output is the bitwise AND of the inputs. Matlab treats any non-zero value as 1 and returns the logical AND. For example (3 &amp;amp; 4) in Numpy is 0, while in Matlab both 3 and 4 are considered logical true and (3 &amp;amp; 4) returns 1.
Precedence: Numpy’s &amp;amp; operator is higher precedence than logical operators like &amp;lt; and &amp;gt;; Matlab’s is the reverse.
If you know you have boolean arguments, you can get away with using Numpy’s bitwise operators, but be careful with parentheses, like this: z = (x &amp;gt; 1) &amp;amp; (x &amp;lt; 2). The absence of Numpy operator forms of logical_and and logical_or is an unfortunate consequence of Python’s design.&lt;/p&gt;
&lt;p&gt;RESHAPE and LINEAR INDEXING: Matlab always allows multi-dimensional arrays to be accessed using scalar or linear indices, Numpy does not. Linear indices are common in Matlab programs, e.g. find() on a matrix returns them, whereas Numpy’s find behaves differently. When converting Matlab code it might be necessary to first reshape a matrix to a linear sequence, perform some indexing operations and then reshape back. As reshape (usually) produces views onto the same storage, it should be possible to do this fairly efficiently. Note that the scan order used by reshape in Numpy defaults to the ‘C’ order, whereas Matlab uses the Fortran order. If you are simply converting to a linear sequence and back this doesn’t matter. But if you are converting reshapes from Matlab code which relies on the scan order, then this Matlab code: z = reshape(x,3,4); should become z = x.reshape(3,4,order=’F’).copy() in Numpy.&lt;/p&gt;
&lt;p&gt;Customizing Your Environment
In MATLAB® the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.&lt;/p&gt;
&lt;p&gt;NumPy, or rather Python, has similar facilities.&lt;/p&gt;
&lt;p&gt;To modify your Python search path to include the locations of your own modules, define the PYTHONPATH environment variable.
To have a particular script file executed when the interactive Python interpreter is started, define the PYTHONSTARTUP environment variable to contain the name of your startup script.
Unlike MATLAB®, where anything on your path can be called immediately, with Python you need to first do an ‘import’ statement to make functions in a particular file accessible.&lt;/p&gt;
&lt;p&gt;For example you might make a startup script that looks like this (Note: this is just an example, not a statement of “best practices”):&lt;/p&gt;
&lt;p&gt;# Make all numpy available via shorter 'num' prefix
import numpy as num
# Make all matlib functions accessible at the top level via M.func()
import numpy.matlib as M
# Make some matlib functions accessible directly at the top level via, e.g. rand(3,3)
from numpy.matlib import rand,zeros,ones,empty,eye
# Define a Hermitian function
def hermitian(A, &lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id7"&gt;&lt;span class="problematic" id="id8"&gt;**&lt;/span&gt;&lt;/a&gt;kwargs):&lt;/p&gt;
&lt;div class="system-message" id="id7"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 284); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id8"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Inline strong start-string without end-string.&lt;/div&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 292)&lt;/p&gt;
Unexpected indentation.&lt;/div&gt;
&lt;blockquote&gt;
return num.transpose(A,**kwargs).conj()&lt;/blockquote&gt;
&lt;div class="system-message"&gt;
&lt;p class="system-message-title"&gt;System Message: WARNING/2 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 293)&lt;/p&gt;
Block quote ends without a blank line; unexpected unindent.&lt;/div&gt;
&lt;p&gt;# Make some shorcuts for transpose,hermitian:
#    num.transpose(A) --&amp;gt; T(A)
#    hermitian(A) --&amp;gt; H(A)
T = num.transpose
H = hermitian
Links
See &lt;a class="reference external" href="http://mathesaurus.sf.net/"&gt;http://mathesaurus.sf.net/&lt;/a&gt; for another MATLAB®/NumPy cross-reference.&lt;/p&gt;
&lt;p&gt;An extensive list of tools for scientific work with python can be found in the topical software page.&lt;/p&gt;
&lt;p&gt;MATLAB® and SimuLink® are registered trademarks of The MathWorks.&lt;/p&gt;
&lt;div class="system-messages section"&gt;
&lt;h2&gt;Docutils System Messages&lt;/h2&gt;
&lt;div class="system-message" id="id9"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 223); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id10"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Unknown target name: "ix".&lt;/div&gt;
&lt;div class="system-message" id="id11"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 263); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id12"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Unknown target name: "r".&lt;/div&gt;
&lt;div class="system-message" id="id13"&gt;
&lt;p class="system-message-title"&gt;System Message: ERROR/3 (&lt;tt class="docutils"&gt;&amp;lt;string&amp;gt;&lt;/tt&gt;, line 263); &lt;em&gt;&lt;a href="https://numython.github.io/posts/numpy-para-usuarios-de-matlab/#id14"&gt;backlink&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
Unknown target name: "r".&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>mathjax</category><category>MATLAB</category><category>NumPy</category><category>python</category><guid>https://numython.github.io/posts/numpy-para-usuarios-de-matlab/</guid><pubDate>Tue, 18 Oct 2016 15:58:03 GMT</pubDate></item><item><title>SymPy, calculando la ecuación de un plano dados tres puntos</title><link>https://numython.github.io/posts/2016/03/sympy-es-una-de-esas-librerias-que-lo/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;SymPy es una de esas librerías que lo mismo sirven para hacer grandes cosas, que para &lt;em&gt;desempolvar&lt;/em&gt; recuerdos y aplicarlos en cuestiones más orientadas a la etapa académica. Y es que las cuestiones de algebra simbólica suelen ser muy divertidas y lo suficientemente interesantes para mantener a un individuo ocupado.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Bueno, sin más preámbulos, en este post vamos a ver cómo utilizar SymPy para calcular la ecuación de un plano dados tres puntos contenidos en este.&lt;/div&gt;&lt;br&gt;Primero un poco de geometría elemental. Sean los tres puntos contenidos en el plano los siguientes:&lt;br&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; = (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; = (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt; = (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;)&lt;/span&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Luego, la ecuación implícita del plano podemos obtenerla resolviendo la ecuación dada por el determinante siguiente:&lt;/div&gt;&lt;br&gt;&lt;span class="math display"&gt;$$ \left|\begin{matrix} x - x_1 &amp;amp; y - y_1 &amp;amp; z - z_1 \\ x_2 - x_1 &amp;amp; y_2 - y_2 &amp;amp; z_2 - z_1 \\ x_3 - x_1 &amp;amp; y_3 - y_1 &amp;amp; z_3 - z_1 \\ \end{matrix}\right| = 0 $$&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;La solución tradicional creo que, llegados a este punto, todos podemos obtenerla sin ningún tipo de sobresalto. Ahora, la idea es implementar una solución utilizando SymPy.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;SymPy dispone de una clase &lt;code style="white-space: pre;"&gt;Matrix&lt;/code&gt;, que recibe como argumentos de entrada una lista de valores numéricos o bien de cualquier variable simbólica que haya sido definida previamente. Está claro que en este caso los valores de las coordenadas de los puntos son conocidos, pero las variables \(x, y, z\) serán variables de tipo simbólico. Para calcular el determinante de una matriz podemos utilizar la función &lt;code style="white-space: pre;"&gt;det&lt;/code&gt;, que recibe como argumento de entrada un objeto de la clase Matrix. Una vez resuelto el determinante tendremos una ecuación de la forma:&lt;/div&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;x&lt;/em&gt; + &lt;em&gt;B&lt;/em&gt;&lt;em&gt;y&lt;/em&gt; + &lt;em&gt;C&lt;/em&gt;&lt;em&gt;z&lt;/em&gt; − &lt;em&gt;k&lt;/em&gt; = 0&lt;/span&gt;&lt;br&gt;&lt;br&gt;Veamos el código implementado en SymPy:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Matrix, det&lt;br&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x,y,z&lt;br&gt;&lt;br&gt;P1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;3&lt;/span&gt;)&lt;br&gt;P2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;br&gt;P3 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;)&lt;br&gt;&lt;br&gt;M &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; Matrix([[x&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]     , y&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]     , z&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]    ,&lt;br&gt;            [P2[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]],&lt;br&gt;            [P3[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]])&lt;br&gt;&lt;br&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st" style="color: #4070a0;"&gt;u"Ecuación implícita: &lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt; = 0"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;det(M))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Lo cual nos devolverá en consola la ecuación implícita del plano:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;Ecuación implícita: &lt;span class="dv" style="color: #40a070;"&gt;13&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; y &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;z &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;9&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Ahora bien, si requerimos la ecuación anterior expresada de forma explícita como una función bivariable del tipo \(z=f(x,y)\), entonces, debemos utilizar la función &lt;code style="white-space: pre;"&gt;solve&lt;/code&gt; y resolver la ecuación planteada respecto a \(z\), por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Matrix, solve, det&lt;br&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x,y,z&lt;br&gt;&lt;br&gt;P1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;3&lt;/span&gt;)&lt;br&gt;P2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;br&gt;P3 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;)&lt;br&gt;&lt;br&gt;M &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; Matrix([[x&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]     , y&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]     , z&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]    ,&lt;br&gt;            [P2[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]],&lt;br&gt;            [P3[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]])&lt;br&gt;&lt;br&gt;sol &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; solve(det(M), z)&lt;br&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st" style="color: #4070a0;"&gt;u"Ecuación implícita: &lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt; = 0"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;det(M))&lt;br&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st" style="color: #4070a0;"&gt;u"Ecuación explícita: z=&lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;(sol[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Resultando:&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;Ecuación implícita: &lt;span class="dv" style="color: #40a070;"&gt;13&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; y &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;z &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;9&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;&lt;br&gt;Ecuación explícita: z&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;13&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; y&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;9&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Incluso podemos graficar nuestro plano utilizando la función &lt;code style="white-space: pre;"&gt;plot3d&lt;/code&gt; del módulo &lt;code style="white-space: pre;"&gt;plotting&lt;/code&gt;:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from sympy import latex&lt;/span&gt;&lt;/code&gt;&lt;br&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.plotting &lt;span class="im"&gt;import&lt;/span&gt; plot3d&lt;br&gt;&lt;br&gt;plot3d(sol[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;], (x,&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;), (y,&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;), title&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"$z = &lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;$"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;(latex(sol[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;])))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-q9746nrlTnw/VtiKBse1HBI/AAAAAAAAByY/npjCaWNgTRA/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="300" src="https://1.bp.blogspot.com/-q9746nrlTnw/VtiKBse1HBI/AAAAAAAAByY/npjCaWNgTRA/s400/img_01.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>CAS</category><category>mathjax</category><category>SymPy</category><guid>https://numython.github.io/posts/2016/03/sympy-es-una-de-esas-librerias-que-lo/</guid><pubDate>Fri, 04 Mar 2016 01:02:00 GMT</pubDate></item><item><title>Funciones definidas a trozos (piecewise) con NumPy</title><link>https://numython.github.io/posts/2016/02/funciones-definidas-trozos-piecewise/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Una función definida a trozos es una función real \(f\) de una variable real \(x\), cuya definición está dada por varios conjuntos disjuntos de su dominio. &lt;sup&gt;[1]&lt;/sup&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;El ejemplo clásico de una función definida por secciones es la función valor absoluto \(abs(x)\), habitualmente definida por:&lt;/div&gt;&lt;br&gt;&lt;span class="math display"&gt;$$ f(x)= |x| = \left\{ \begin{matrix} -x &amp;amp; si \,\, x &amp;lt; 0 \\ x &amp;amp; si \,\, x \geq 0 \\ \end{matrix}\right. $$&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;De manera ordinaria, en NumPy, para definir una función en un intervalo tendríamos que crear un vector de \(n\) cantidad de puntos en ese intervalo, y posteriormente crear la expresión que define la función, por ejemplo, definiendo a \(f(x)=x\,\,cos(x)\)&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;np.linspace(&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;x&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;np.cos(x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Ahora, dada la naturaleza de las funciones por tramos, estás no pueden definirse como en las líneas anteriores, puesto que la expresión que las define depende del intervalo. Una opción para crear una función a trozos sería definiendo un intervalo para cada expresión y posteriormente concatenar todo en un mismo arreglo, tanto para los intervalos como las expresiones.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Por ejemplo, definiendo la función valor absoluto en el intervalo \((-10,10)\):&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;x1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;)&lt;br&gt;x2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;)&lt;br&gt;y1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;x1&lt;br&gt;y2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; x2&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.concatenate((x1,x2))&lt;br&gt;y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.concatenate((y1,y2))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Si, lo anterior puede parecer un poco &lt;em&gt;tedioso&lt;/em&gt;, así que NumPy también dispone de una función que nos ahorra el estar escribiendo mucho código: &lt;code style="white-space: pre;"&gt;piecewise&lt;/code&gt;, la cual nos permite crear un arreglo a partir de otro (intervalo), seccionando este acorde a las expresiones/funciones pasadas como argumentos y a las condiciones lógicas para definir los subintervalos. En términos simples la sintaxis de &lt;code style="white-space: pre;"&gt;piecewise&lt;/code&gt; es:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;np.piecewise(x, logls, funls)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Donde &lt;code style="white-space: pre;"&gt;x&lt;/code&gt; es un arreglo que define la variable independiente, &lt;code style="white-space: pre;"&gt;logls&lt;/code&gt; una lista de condiciones lógicas para seccionar y definir los subintervalos, y &lt;code style="white-space: pre;"&gt;funls&lt;/code&gt; una lista de funciones o constantes que definen el valor de la función para el subintervalo correspondiente.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Siguiendo con nuestro ejemplo de la función valor absoluto, haríamos algo como lo siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;)&lt;br&gt;y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.piecewise(x, [x&lt;span class="op" style="color: #666666;"&gt;&amp;lt;&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;, x&lt;span class="op" style="color: #666666;"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;], [&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;x, &lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: x])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Desde luego también se pueden usar funciones ordinarias en lugar de lambdas.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Para hacer esto un poco más &lt;em&gt;ilustrativo&lt;/em&gt; vamos a utilizar Matplotlib para trazar la gráfica correspondiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt &lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;)&lt;br&gt;y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.piecewise(x, [x&lt;span class="op" style="color: #666666;"&gt;&amp;lt;&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;, x&lt;span class="op" style="color: #666666;"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;], [&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;x, &lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: x])&lt;br&gt;&lt;br&gt;plt.plot(x, y)&lt;br&gt;&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Funciones%20definidas%20a%20trozos%20(piecewise)%20con%20Numpy/img/img_01.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://2.bp.blogspot.com/-Wrz9la4Vedg/VtS0t9Vt9AI/AAAAAAAAByE/abcTdoAzXEU/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="300" src="https://2.bp.blogspot.com/-Wrz9la4Vedg/VtS0t9Vt9AI/AAAAAAAAByE/abcTdoAzXEU/s400/img_01.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;strong&gt;Referencias:&lt;/strong&gt;&lt;br&gt;[1]. &lt;a href="https://es.wikipedia.org/wiki/Funci%C3%B3n_definida_a_trozos"&gt;https://es.wikipedia.org/wiki/Funci%C3%B3n_definida_a_trozos&lt;/a&gt;</description><category>mathjax</category><category>NumPy</category><guid>https://numython.github.io/posts/2016/02/funciones-definidas-trozos-piecewise/</guid><pubDate>Tue, 01 Mar 2016 03:15:00 GMT</pubDate></item><item><title>Graficar en Python con Matplotlib y NumPy</title><link>https://numython.github.io/posts/2016/02/graficar-en-python-con-matplotlib-y/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Trazar gráficas en Python es muy sencillo, para ello necesita tener instaladas las librerías matplotlib y numpy, las cuales pueden encontrarse y descargar de la red sin mayores obstáculos. Debe asegurarse que la versión de las librerías sea compatible con la versión de Python.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Si alguna vez ha utilizado MATLAB para estos mismos fines, las instrucciones le parecerán demasiado familiar.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Enseguida os adjunto un código sencillo y el resultado que produce:&lt;/div&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;import matplotlib.pyplot as plt&lt;br&gt;import numpy as np&lt;br&gt;&lt;br&gt;x = np.arange(0,10,0.1)&lt;br&gt;y = x*np.cos(x)&lt;br&gt;&lt;br&gt;plt.plot(x,y)&lt;br&gt;plt.xlabel('x')&lt;br&gt;plt.ylabel('y')&lt;br&gt;plt.title('Lab DLS')&lt;br&gt;plt.show()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-F1Qzh-W-7Gw/UxvtzNBs2VI/AAAAAAAABEk/wYX758jaymM/s1600/graph1.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="271" src="https://2.bp.blogspot.com/-F1Qzh-W-7Gw/UxvtzNBs2VI/AAAAAAAABEk/wYX758jaymM/s1600/graph1.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Las primeras dos líneas sirven para importar las librerías que se utilizarán. Recuerde que en Python pueden utilizarse seudónimos al cargar una librería (en este caso plt para matplotlib.pyplot y np para numpy).&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;En la línea se 4 se define el vector de la variable independiente utilizando la instrucción arange de la librería numpy, el cual crea un vector especificando el valor inicial, el valor final y el incremento como argumentos. La linea 5 crea simplemente un vector dependiente del primero.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;La instrucción plot gráfica los vectores creados con anterioridad, teniendo como primer argumento el vector de la variable independiente. Con xlabel, ylabel y title se muestran las etiquetas correspondientes a los ejes horizontal, vertical y el título en la parte superior respectivamente. Finalmente, la instrucción show() sirve para mostrar la ventana gráfica creada y poder visualizar lo que se ha trazado.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;b&gt;&lt;span style="font-size: large;"&gt;Modificando la presentación...&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br&gt;&lt;i&gt;Grosor de línea&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Para modificar el grosor de línea basta con incluir como argumento adicional en plot la propiedad linewidth, tal como se muestra enseguida:&lt;/div&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.plot(x,y,linewidth=4)&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;i&gt;Color de línea&lt;/i&gt;&lt;br&gt;&lt;br&gt;El siguiente ejemplo configura el color de la línea, en este caso rojo.&lt;br&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.plot(x,y,color='r')&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;También puede especificar el color utilizando una tupla de 3 elementos (R,G,B) en el intervalo [0 1], por ejemplo:&lt;/div&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.plot(x,y,color=(0.8,0.9,0))&lt;/pre&gt;&lt;br&gt;&lt;i&gt;Agregando rejilla&lt;/i&gt;&lt;br&gt;&lt;br&gt;Para agregar una rejilla debe incluirse la instrucción grid() como se muestra:&lt;br&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.grid()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;span style="font-size: large;"&gt;Mostrar más de una gráfica&lt;/span&gt;&lt;/b&gt;&lt;br&gt;&lt;br&gt;Para mostrar más de una gráfica en la misma ventana, utilice hold(True) después de haber creado la primer gráfica o bien antes de ella, tal como se muestra en el código siguiente:&lt;br&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;import matplotlib.pyplot as plt&lt;br&gt;import numpy as np&lt;br&gt;&lt;br&gt;x = np.arange(0,10,0.2)&lt;br&gt;y1 = np.cos(x)&lt;br&gt;y2 = np.sin(x)&lt;br&gt;&lt;br&gt;plt.plot(x,y1,'o',linewidth=3,color=(0.2,0.1,0.4))&lt;br&gt;plt.hold(True)&lt;br&gt;plt.plot(x,y2,'-',linewidth=2,color='g')&lt;br&gt;plt.grid()&lt;br&gt;plt.axis('equal')&lt;br&gt;plt.xlabel('x')&lt;br&gt;plt.ylabel('y')&lt;br&gt;plt.title('Lab DLS')&lt;br&gt;plt.show()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-zLEWNeou8Ck/UxwGMYIi3wI/AAAAAAAABE0/m1tXOSZnuOM/s1600/graph2.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="270" src="https://3.bp.blogspot.com/-zLEWNeou8Ck/UxwGMYIi3wI/AAAAAAAABE0/m1tXOSZnuOM/s1600/graph2.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description><category>mathjax</category><category>Matplotlib</category><category>NumPy</category><guid>https://numython.github.io/posts/2016/02/graficar-en-python-con-matplotlib-y/</guid><pubDate>Wed, 24 Feb 2016 22:52:00 GMT</pubDate></item><item><title>Gráficas de barras en Matplotlib</title><link>https://numython.github.io/posts/2016/02/graficas-de-barras-en-matplotlib/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;p&gt;Esta entrada tiene como objetivo mostrar el uso de Matplotlib/Python como herramienta para generar una gráfica de barras.&lt;br&gt;&lt;br&gt;Bien, para nuestro ejemplo vamos a suponer que se tienen como datos las calificaciones de 5 alumnos guardadas en una lista, y que tenemos también otra lista con los nombres correspondientes a cada uno, evidentemente en el mismo orden. Os adjunto el script y enseguida la explicación de cada linea:&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class="brush: python"&gt;#-*- coding: utf-8 -*-&lt;br&gt;import matplotlib.pyplot as plt&lt;br&gt;&lt;br&gt;fig = plt.figure(u'Gráfica de barras') # Figure&lt;br&gt;ax = fig.add_subplot(111) # Axes&lt;br&gt;&lt;br&gt;nombres = ['Juan','Ana','Pablo','Ximena','Jorge']&lt;br&gt;datos = [90,88,78,94,93]&lt;br&gt;xx = range(len(datos))&lt;br&gt;&lt;br&gt;ax.bar(xx, datos, width=0.8, align='center')&lt;br&gt;ax.set_xticks(xx)&lt;br&gt;ax.set_xticklabels(nombres)&lt;br&gt;&lt;br&gt;plt.show()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;La primera linea sirve para especificar la codificación utilizada en el fichero y con ello evitar todo tipo de "sorpresas" debido a la peculiaridad de nuestro idioma, de modo que es necesaria. La segunda linea importa el módulo pyplot de la librería Matplotlib utilizando el alias plt.&lt;br&gt;&lt;br&gt;Luego, creamos una nueva ventana mediante el uso de figure, y añadimos enseguida un axes mediante la instrucción add_subplot(111), donde el 111 indica que solamente se tendrá un eje coordenado dentro de la ventana.&lt;br&gt;&lt;br&gt;Posteriormente se definen las listas que servirán como entrada para trazar la gráfica de barras. En la lista nombre se guarda un arreglo de strings con los nombres de cada alumno, en datos se guardan las calificaciones correspondientes y xx es una lista de enteros desde 0 a N-1, donde N es el número de elementos que contiene la lista datos, xx servirá para especificar los puntos ubicados en el eje horizontal en los cuales se trazarán las barras.&lt;br&gt;&lt;br&gt;Una vez se han creado las listas, se procede a trazar la gráfica de barras mediante la función bar, cuyos parámetros de entrada son la lista xx y la lista de datos y/o calificaciones. Además de lo anterior, pueden utilizarse keywords arguments como width o align que sirven para especificar el ancho y la alineación de las barras trazadas. Luego, la función set_xticks define las marcas utilizadas para etiquetar al eje horizontal, y set_xticklabels permite colocar una lista de strings como etiquetas personalizadas, que en este caso corresponde a la lista de nombres.&lt;br&gt;&lt;br&gt;Finalmente se utiliza la función show para mostrar todo lo que se ha trazado. Se adjunta la salida gráfica del script en cuestión.&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-x2jFDeLSido/VKTKUfDsciI/AAAAAAAABY8/K_dbQk01FFg/s1600/Captura.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="267" src="https://4.bp.blogspot.com/-x2jFDeLSido/VKTKUfDsciI/AAAAAAAABY8/K_dbQk01FFg/s1600/Captura.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>Gráficas</category><category>mathjax</category><category>Matplotlib</category><guid>https://numython.github.io/posts/2016/02/graficas-de-barras-en-matplotlib/</guid><pubDate>Wed, 24 Feb 2016 22:47:00 GMT</pubDate></item><item><title>Sympy live, una "consola" de Python online.</title><link>https://numython.github.io/posts/2016/02/sympy-live-una-consola-de-python-online/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Sympy live (&lt;a href="http://live.sympy.org/"&gt;http://live.sympy.org/&lt;/a&gt;) es una aplicación web que permite ejecutar código Python en línea, y claro, con la ventaja que permite utilizar la librería Sympy para realizar cálculos de computación simbólica.&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-5Blr-tcS2pw/VopXqOBMfRI/AAAAAAAABok/9qElSzxoku0/s1600/img_01.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="494" src="https://3.bp.blogspot.com/-5Blr-tcS2pw/VopXqOBMfRI/AAAAAAAABok/9qElSzxoku0/s640/img_01.PNG" width="640"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;A continuación se muestran algunas operaciones realizadas utilizando esta aplicación.&lt;br&gt;&lt;br&gt;&lt;b&gt;Manipulación algebraica&lt;/b&gt;&lt;br&gt;&lt;br&gt;Expandiendo la expresión $(x+1) ^2$ y factorizando $x^2+6x-16$:&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-BRQbsDTb82E/Vopbbk92tmI/AAAAAAAABo0/xjhaKkEQzmA/s1600/img_02.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://1.bp.blogspot.com/-BRQbsDTb82E/Vopbbk92tmI/AAAAAAAABo0/xjhaKkEQzmA/s1600/img_02.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b&gt;Resolviendo ecuaciones e inecuaciones&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-Yh_YU2wHOLc/VopfzJchnbI/AAAAAAAABpE/vA9ZagdGHb0/s1600/img_03.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://2.bp.blogspot.com/-Yh_YU2wHOLc/VopfzJchnbI/AAAAAAAABpE/vA9ZagdGHb0/s1600/img_03.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Sistemas de ecuaciones lineales&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-NYQtAAGXTC4/Vopf3AOHhVI/AAAAAAAABpM/F09PC_J7ZJg/s1600/img_04.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://4.bp.blogspot.com/-NYQtAAGXTC4/Vopf3AOHhVI/AAAAAAAABpM/F09PC_J7ZJg/s1600/img_04.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Derivadas&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-wrN943SLJXQ/VophtmPZ88I/AAAAAAAABpY/fPMl18OxRFk/s1600/img_05.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://1.bp.blogspot.com/-wrN943SLJXQ/VophtmPZ88I/AAAAAAAABpY/fPMl18OxRFk/s1600/img_05.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b&gt;Integrales&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-BpmobKGJMD8/Vophu2QYH2I/AAAAAAAABpg/anefRm29pA0/s1600/img_06.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://3.bp.blogspot.com/-BpmobKGJMD8/Vophu2QYH2I/AAAAAAAABpg/anefRm29pA0/s1600/img_06.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Integrales múltiples&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-C67lhgBWVrs/VopjGJyLH6I/AAAAAAAABps/e2F3Vx-_6iE/s1600/img_07.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://4.bp.blogspot.com/-C67lhgBWVrs/VopjGJyLH6I/AAAAAAAABps/e2F3Vx-_6iE/s1600/img_07.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Ecuaciones diferenciales&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-fxu-0EXJlnQ/VopnQA-AqfI/AAAAAAAABqE/h-I3xc2BD6c/s1600/img_08.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://3.bp.blogspot.com/-fxu-0EXJlnQ/VopnQA-AqfI/AAAAAAAABqE/h-I3xc2BD6c/s1600/img_08.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>CAS</category><category>mathjax</category><category>SymPy</category><guid>https://numython.github.io/posts/2016/02/sympy-live-una-consola-de-python-online/</guid><pubDate>Wed, 24 Feb 2016 22:46:00 GMT</pubDate></item><item><title>Borrar líneas en Matplotlib de manera interactiva</title><link>https://numython.github.io/posts/2016/02/borrar-lineas-en-matplotlib-de-manera/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Matplotlib es una librería normalmente utilizada para trazar gráficas que habrán de exportarse como un archivo "estático" e incluirse en algún tipo de documento posteriormente. Pero además, Matplotlib también tiene algunas características que permiten que el usuario pueda interactuar, tales como los widgets o los eventos definidos por el usuario. Y esta última característica vamos a aprovechar en este post para ver cómo poder borrar líneas de una gráfica Matplotlib una vez que esta ha sido creada, esto mediante la selección a través del mouse.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Los eventos en Matplotlib se "conectan" utilizando el método &lt;code style="white-space: pre;"&gt;mpl_connect&lt;/code&gt; de la clase &lt;code style="white-space: pre;"&gt;FigureCanvas&lt;/code&gt;, mediante la sintaxis siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;hevt &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;'tipo_evento'&lt;/span&gt;, fun)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Donde &lt;code style="white-space: pre;"&gt;hevt&lt;/code&gt; es una variable en la cual se guarda la referencia al evento y que puede ser utilizada para desconectarlo cuando no lo necesitemos más, &lt;code style="white-space: pre;"&gt;fig&lt;/code&gt; es una instancia de la clase &lt;code style="white-space: pre;"&gt;Figure&lt;/code&gt;, &lt;code style="white-space: pre;"&gt;tipo_evento&lt;/code&gt; es uno de los eventos que pueden ser conectados en Matplotlib, cuya lista puede ver &lt;a href="http://matplotlib.org/users/event_handling.html#event-connections"&gt;aquí&lt;/a&gt;, y &lt;code style="white-space: pre;"&gt;fun&lt;/code&gt; es una función en la cual deberá programarse la respuesta de nuestro programa cuando se lance el evento.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Por ahora nos interesa el tipo de evento &lt;code style="white-space: pre;"&gt;pick_event&lt;/code&gt;, el cual se "lanza" cuando un objeto en el canvas actual es seleccionado. Así, para conectar nuestro evento haremos algo como lo siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;pick &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;"pick_event"&lt;/span&gt;, OnSelect)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Ahora vamos a por todo el código y enseguida explicamos para qué cada cosa:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; wx&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;def&lt;/span&gt; OnSelect(event):&lt;br&gt;    app &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.App()&lt;br&gt;    dlg &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.MessageDialog(&lt;span class="va" style="color: #19177c;"&gt;None&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;"Desea borrar"&lt;/span&gt;,&lt;br&gt;    &lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;'Matplotlib Demo'&lt;/span&gt;, wx.YES_NO&lt;span class="op" style="color: #666666;"&gt;|&lt;/span&gt;wx.ICON_QUESTION)&lt;br&gt;    &lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;if&lt;/span&gt; dlg.ShowModal() &lt;span class="op" style="color: #666666;"&gt;==&lt;/span&gt; wx.ID_YES:&lt;br&gt;        event.artist.remove()&lt;br&gt;    dlg.Destroy()&lt;br&gt;    app.MainLoop()&lt;br&gt;    fig.canvas.draw()&lt;br&gt;&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Definir datos a plotear&lt;/span&gt;&lt;br&gt;X &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.random.random((&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;))&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Crear figure y axes&lt;/span&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Graficar datos&lt;/span&gt;&lt;br&gt;ax.plot(X, picker&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="va" style="color: #19177c;"&gt;True&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Conectar evento "pick_event"&lt;/span&gt;&lt;br&gt;pick &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;"pick_event"&lt;/span&gt;, OnSelect)&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://4.bp.blogspot.com/-3IUBZXZPaX0/Vs12S30wNaI/AAAAAAAABxU/cD9orfSktFo/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="268" src="https://4.bp.blogspot.com/-3IUBZXZPaX0/Vs12S30wNaI/AAAAAAAABxU/cD9orfSktFo/s320/img_01.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Primero, importamos, claro, los módulos a utilizar. Lo de wxPython es &lt;em&gt;opcional&lt;/em&gt;, sólo nos servirá para confirmar si realmente queremos borrar cierta línea y puede sustituirse con cualquier otra librería gráfica, Tkinter por ejemplo. Luego, definimos unos datos aleatorios, creamos nuestra &lt;code style="white-space: pre;"&gt;Figure&lt;/code&gt; y nuestro &lt;code style="white-space: pre;"&gt;Axes&lt;/code&gt; de la manera en que se debe, y posteriormente &lt;em&gt;ploteamos&lt;/em&gt; los datos utilizando &lt;code style="white-space: pre;"&gt;plot&lt;/code&gt;, pero adicionando el&lt;em&gt;keyword argument&lt;/em&gt; &lt;code style="white-space: pre;"&gt;picker=True&lt;/code&gt; para decirle a Matplotlib que para nuestro objeto gráfico resultante requerimos que esté disponible para ser seleccionado mediante el mouse. Y finalmente conectamos el evento de tipo &lt;code style="white-space: pre;"&gt;"pick_event"&lt;/code&gt; al canvas correspondiente, pasando a la función &lt;code style="white-space: pre;"&gt;OnSelect&lt;/code&gt; como la encargada de &lt;em&gt;dar una respuesta&lt;/em&gt; a ese evento.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;La función &lt;code style="white-space: pre;"&gt;OnSelect&lt;/code&gt; bien puede reducirse a dos líneas si es que no requerimos confirmación de borrado, algo como:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;def&lt;/span&gt; OnSelect(event):&lt;br&gt;    event.artist.remove()&lt;br&gt;    fig.canvas.draw()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;El resto de código es para crear un cuadro de diálogo en wxPython que nos pregunta si realmente queremos borrar la línea que hemos seleccionado.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Borrar%20lineas%20en%20Matplotlib%20de%20manera%20interactiva/img/img_01.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Podríamos &lt;em&gt;mejorar&lt;/em&gt; un poquito nuestro "demo" si por ejemplo cada vez que seleccionamos una línea esta sea modificada para distinguirse un poco más del resto, por ejemplo modificar su grosor, y en caso de no confirmar su borrado entonces regresar al aspecto original. Agregando algunas líneas nos queda un código más o menos como este:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; wx&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;def&lt;/span&gt; OnSelect(event):&lt;br&gt;    klw &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;&lt;br&gt;    event.artist.set_lw(event.artist.get_lw() &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; klw)&lt;br&gt;    fig.canvas.draw()&lt;br&gt;    app &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.App()&lt;br&gt;    dlg &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.MessageDialog(&lt;span class="va" style="color: #19177c;"&gt;None&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;"Desea borrar"&lt;/span&gt;,&lt;br&gt;    &lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;'Matplotlib Demo'&lt;/span&gt;, wx.YES_NO&lt;span class="op" style="color: #666666;"&gt;|&lt;/span&gt;wx.ICON_QUESTION)&lt;br&gt;    &lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;if&lt;/span&gt; dlg.ShowModal() &lt;span class="op" style="color: #666666;"&gt;==&lt;/span&gt; wx.ID_YES:&lt;br&gt;        event.artist.remove()&lt;br&gt;    &lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;else&lt;/span&gt;:&lt;br&gt;        event.artist.set_lw(event.artist.get_lw() &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; klw)&lt;br&gt;    dlg.Destroy()&lt;br&gt;    app.MainLoop()&lt;br&gt;    fig.canvas.draw()&lt;br&gt;&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Definir datos a plotear&lt;/span&gt;&lt;br&gt;X &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.random.random((&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;))&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Crear figure y axes&lt;/span&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Graficar datos&lt;/span&gt;&lt;br&gt;ax.plot(X, picker&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="va" style="color: #19177c;"&gt;True&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Conectar evento "pick_event"&lt;/span&gt;&lt;br&gt;pick &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;"pick_event"&lt;/span&gt;, OnSelect)&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Borrar%20lineas%20en%20Matplotlib%20de%20manera%20interactiva/img/img_02.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-yqflea3-OII/Vs12TDN5p0I/AAAAAAAABxY/Q6NiQ0rhYms/s1600/img_02.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="267" src="https://1.bp.blogspot.com/-yqflea3-OII/Vs12TDN5p0I/AAAAAAAABxY/Q6NiQ0rhYms/s320/img_02.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Y bueno, con esto finalizamos esta pequeña introducción a las formas interactivas de Matplotlib, desde luego existen muchas posibilidades para implementar, de tal modo que nos quede algo más &lt;em&gt;chulo&lt;/em&gt;.&lt;/div&gt;</description><category>mathjax</category><category>Matplotlib</category><category>wxPython</category><guid>https://numython.github.io/posts/2016/02/borrar-lineas-en-matplotlib-de-manera/</guid><pubDate>Wed, 24 Feb 2016 15:24:00 GMT</pubDate></item><item><title>Una introducción a SymPy</title><link>https://numython.github.io/posts/2016/02/una-introduccion-sympy/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;p&gt;SymPy es una librería de Python desarrollada para resolver problemas de matemáticas simbólicas. Existen diversos software comerciales que realizan estas tareas: Maple, Mathematica, MATLAB, entre otros, pero requieren una licencia de uso que puede resultar poco accesible en algunos casos. En cambio, SymPy se distribuye bajo licencia BSD, que en resumen permite el uso libre de la misma.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id="importando-sympy"&gt;Importando SymPy&lt;/h3&gt;Para importar SymPy y disponer de todos los módulos y funciones que le componen puede hacerse de diversas formas:&lt;br&gt;&lt;ol&gt;&lt;li&gt;Forma tradicional&lt;/li&gt;&lt;/ol&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; sympy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Es la manera más habitual, se carga toda la librería y se accede a cada una de las funciones mediante la sintaxis:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; r&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;sympy.funcion(args)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;&lt;li&gt;Importando funciones seleccionadas&lt;/li&gt;&lt;/ol&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol,integrate,sin,cos&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;De este modo se importan solamente las funciones que vayan a utilizarse, es recomendable cuando se utilizará un número reducido de las mismas. Proporciona cierta ventaja dado que para acceder a una función no es necesario anteponer el nombre de la librería (sympy), aunque esto mismo represente una desventaja en aquellos casos en los que existen funciones de diferentes librerías con el mismo nombre.&lt;br&gt;&lt;ol start="3"&gt;&lt;li&gt;Utilizando un alias o seudónimo&lt;/li&gt;&lt;/ol&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; sympy &lt;span class="im"&gt;as&lt;/span&gt; sp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Funciona del mismo modo que para el primer caso, con la diferencia que el usuario puede asignarle un nombre más corto o bien más representativo para hacer las llamadas a funciones.&lt;br&gt;Para los ejemplos que se mostrarán en esta entrada se utilizará la segunda forma.&lt;br&gt;&lt;br&gt;&lt;h3 id="declarando-una-variable-simbólica"&gt;Declarando una variable simbólica&lt;/h3&gt;&lt;br&gt;Para declarar una variable simbólica podemos utilizar la función Symbol, para ello primero importamos la función y posteriormente declaramos una variable simbólica "x":&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;Symbol(&lt;span class="st" style="color: #4070a0;"&gt;'x'&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;br&gt;x&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="dv" style="color: #40a070;"&gt;+2&lt;/span&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Como puede verse, una vez se ha declarado la variable simbólica podemos utilizarle para formar expresiones algebraicas de todo tipo. Existe una forma más "simple" de declarar una variable simbólica, para ello habrá de importarse del módulo "abc" la letra correspondiente, por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;O bien:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x,y,z&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Lo anterior en el caso de que se requieran múltiples variables simbólicas.&lt;br&gt;&lt;br&gt;&lt;h3 id="manipulaciones-algebraicas"&gt;Manipulaciones algebraicas&lt;/h3&gt;&lt;h4 id="factorizar-una-expresión-algebraica."&gt;&lt;br&gt;&lt;/h4&gt;&lt;h4 id="factorizar-una-expresión-algebraica."&gt;Factorizar una expresión algebraica.&lt;/h4&gt;Para factorizar una expresión algebraica podemos utilizar la función factor, por ejemplo suponga que se quiere factorizar la expresión (x^2+2x+1):&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; factor,Symbol&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;Symbol(&lt;span class="st" style="color: #4070a0;"&gt;'x'&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; factor(x&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2+2&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x&lt;span class="dv" style="color: #40a070;"&gt;+1&lt;/span&gt;)&lt;br&gt;(x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="expandir-una-expresión-algebraica"&gt;&lt;br&gt;&lt;/h4&gt;&lt;h4 id="expandir-una-expresión-algebraica"&gt;Expandir una expresión algebraica&lt;/h4&gt;&lt;br&gt;Enseguida se muestra un ejemplo de cómo "expandir" o multiplicar dos expresiones algebraicas.&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol,expand&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;Symbol(&lt;span class="st" style="color: #4070a0;"&gt;'x'&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; expand((x&lt;span class="dv" style="color: #40a070;"&gt;+2&lt;/span&gt;)&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;(x&lt;span class="dv" style="color: #40a070;"&gt;-3&lt;/span&gt;))&lt;br&gt;x&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; x &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>CAS</category><category>mathjax</category><category>SymPy</category><guid>https://numython.github.io/posts/2016/02/una-introduccion-sympy/</guid><pubDate>Wed, 24 Feb 2016 13:58:00 GMT</pubDate></item><item><title>Gráficas de contorno en Matplotlib</title><link>https://numython.github.io/posts/2016/02/graficas-de-contorno-en-matplotlib/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;p&gt;Una manera de visualizar una función de dos variables es usar un campo escalar, en el que el escalar \(z = f(x,y)\) se asigna al punto \((x,y)\). Un campo escalar puede caracterizarse por sus curvas de nivel (o líneas de contorno) a lo largo de las cuales el valor de \(f(x,y)\) es constante.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://3.bp.blogspot.com/-gGA-OfOTy4o/Vs1bGZd--FI/AAAAAAAABw8/AH84hgg1CdE/s1600/surface.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="240" src="https://3.bp.blogspot.com/-gGA-OfOTy4o/Vs1bGZd--FI/AAAAAAAABw8/AH84hgg1CdE/s320/surface.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;El trazo de gráficas de lineas de contorno o curvas de nivel puede hacerse en Matplotlib utilizando la función &lt;code style="white-space: pre;"&gt;contour&lt;/code&gt;, por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt &lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;100&lt;/span&gt;)&lt;br&gt;X,Y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.meshgrid(x,y)&lt;br&gt;Z &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;4&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;X)&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;(X&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; Y&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;br&gt;&lt;br&gt;cs &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; ax.contour(X,Y,Z)&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Gr%C3%A1ficas%20de%20contorno%20en%20Matplotlib/img/img_01.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-kbkYiQIYMo0/Vs1bFMkTiiI/AAAAAAAABww/DmM8liftudo/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="240" src="https://1.bp.blogspot.com/-kbkYiQIYMo0/Vs1bFMkTiiI/AAAAAAAABww/DmM8liftudo/s320/img_01.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;Podemos aumentar el número de niveles si agregamos un argumento de entrada a la función &lt;code style="white-space: pre;"&gt;contour&lt;/code&gt;, por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;cs &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; ax.contour(X, Y, Z, &lt;span class="dv" style="color: #40a070;"&gt;20&lt;/span&gt;)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Con lo anterior tendríamos representados 20 niveles o 20 &lt;em&gt;planos&lt;/em&gt; de valores constantes &lt;span class="math inline"&gt;&lt;em&gt;f&lt;/em&gt;(&lt;em&gt;x&lt;/em&gt;, &lt;em&gt;y&lt;/em&gt;)=&lt;em&gt;C&lt;/em&gt;&lt;/span&gt;.&lt;br&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Gr%C3%A1ficas%20de%20contorno%20en%20Matplotlib/img/img_02.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://4.bp.blogspot.com/-0deFz5SjWV4/Vs1bFiqGfBI/AAAAAAAABw4/ahJye76QOgQ/s1600/img_02.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="240" src="https://4.bp.blogspot.com/-0deFz5SjWV4/Vs1bFiqGfBI/AAAAAAAABw4/ahJye76QOgQ/s320/img_02.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;Se pueden agregar etiquetas a cada curva de nivel si utilizamos el método &lt;code style="white-space: pre;"&gt;clabel&lt;/code&gt;, por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt &lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;100&lt;/span&gt;)&lt;br&gt;X,Y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.meshgrid(x,y)&lt;br&gt;Z &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;4&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;X)&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;(X&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; Y&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;br&gt;&lt;br&gt;cs &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; ax.contour(X, Y, Z, &lt;span class="dv" style="color: #40a070;"&gt;15&lt;/span&gt;)&lt;br&gt;ax.clabel(cs, fontsize&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;)&lt;br&gt;&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://4.bp.blogspot.com/-Bn_XDTuP_MA/Vs1bFpZDLVI/AAAAAAAABw0/jXFruvBtz-w/s1600/img_03.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="240" src="https://4.bp.blogspot.com/-Bn_XDTuP_MA/Vs1bFpZDLVI/AAAAAAAABw0/jXFruvBtz-w/s320/img_03.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>Gráficas</category><category>mathjax</category><category>Matplotlib</category><guid>https://numython.github.io/posts/2016/02/graficas-de-contorno-en-matplotlib/</guid><pubDate>Wed, 24 Feb 2016 13:27:00 GMT</pubDate></item><item><title>Introducción a scikit-image, procesamiento de imágenes en Python</title><link>https://numython.github.io/posts/2016/01/introduccion-scikit-image-procesamiento/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;En este post vamos a hacer una pequeña introducción a la librería scikit-image, la cual básicamente es una colección de algoritmos para el procesamiento de imágenes en Python.&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;h2 id="para-comenzar"&gt;Para comenzar&lt;/h2&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;Todas las instrucciones referente a descarga e instalación, así como algunos códigos de ejemplos pueden encontrarse en la página oficial: &lt;a class="uri" href="http://scikit-image.org/"&gt;http://scikit-image.org/&lt;/a&gt;.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;A manera de referencia rápida, puede instalar scikit-image utilizando pip:&lt;/div&gt;&lt;br&gt;&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt; pip install -U scikit-image&lt;/code&gt;&lt;/pre&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;En general, scikit-image o skimage, trabaja con arrays de numpy, así como también hace uso de algunas utilidades gráficas de Matplotlib para la visualización, por ello también es necesario tener instaladas las librerías SciPy, Matplotlib, NetWorkX, y PIL/pillow.&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;h2 id="lo-muy-básico-cómo-leer-y-mostrar-imágenes"&gt;Lo muy básico: cómo leer y mostrar imágenes&lt;/h2&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;Bueno, aquí un primer ejemplo de cómo leer y mostrar una imagen desde un archivo. Tenemos una imagen llamada "lenna.png" en el mismo directorio de nuestro código, luego, podemos utilizar el módulo &lt;code style="white-space: pre;"&gt;io&lt;/code&gt;de &lt;code style="white-space: pre;"&gt;scikit-image&lt;/code&gt; para leer y mostrar esta imagen. Básicamente se procede como sigue:&lt;/div&gt;&lt;br&gt;Primero importamos el modulo correspondiente:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; skimage &lt;span class="im"&gt;import&lt;/span&gt; io&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Ahora utilizamos la función &lt;code style="white-space: pre;"&gt;imread&lt;/code&gt; del módulo &lt;code style="white-space: pre;"&gt;io&lt;/code&gt; para leer la imagen, y guardamos esto en una variable, en la cual se almacenará un array de NumPy con la información de los colores que componen la imagen.&lt;/div&gt;&lt;br&gt;&lt;code style="white-space: pre;"&gt;img = io.imread('lenna.png')&lt;/code&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Enseguida utilizamos la función &lt;code style="white-space: pre;"&gt;imshow&lt;/code&gt; para mostrar la imagen que pasemos como argumento y la función &lt;code style="white-space: pre;"&gt;show&lt;/code&gt; para mostrar toda la ventana o &lt;code style="white-space: pre;"&gt;figure&lt;/code&gt; que contiene la(s) imágenes a desplegar en la pantalla.&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;io.imshow(img)&lt;br&gt;io.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Juntando este mini código nos quedaría algo como lo siguiente:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; skimage &lt;span class="im"&gt;import&lt;/span&gt; io&lt;br&gt;&lt;br&gt;img &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; io.imread(&lt;span class="st" style="color: #4070a0;"&gt;"lenna.png"&lt;/span&gt;)&lt;br&gt;io.imshow(img)&lt;br&gt;io.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Si ejecutamos lo anterior nos mostrará la imagen leída en una ventana o &lt;code style="white-space: pre;"&gt;figure&lt;/code&gt; de Matplotlib, tal como se aprecia en la siguiente imagen:&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-vD0rh5vdTFE/VqrkeT3ulNI/AAAAAAAABt4/XIukKAVpSYM/s1600/img_01.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="268" src="https://4.bp.blogspot.com/-vD0rh5vdTFE/VqrkeT3ulNI/AAAAAAAABt4/XIukKAVpSYM/s320/img_01.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Podemos &lt;em&gt;averiguar&lt;/em&gt; la forma o cantidad de elementos del array &lt;code style="white-space: pre;"&gt;img&lt;/code&gt; utilizando el método &lt;code style="white-space: pre;"&gt;shape&lt;/code&gt;, por ejemplo en el script anterior se puede añadir:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="bu"&gt;print&lt;/span&gt; img.shape&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Y con ello nos mostrará en consola una tupla de 3 elementos (para el caso de esta imagen) con la información del número de filas, columnas y &lt;em&gt;capas&lt;/em&gt; de la matriz. En nuestro ejemplo nos muestra:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;(512L, 512L, 3L)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Lo cual implica que tenemos una imagen de 512x512 pixeles. El tercer número indica que tenemos tres capas o &lt;em&gt;canales&lt;/em&gt; del módelo de color RGB, en el cual la primer capa representa el rojo, la segunda el verde y la tercera el azul. Así, toda la gama de colores para un pixel en específico se puede obtener mediante la combinación de estos tres colores primarios.&lt;br&gt;&lt;br&gt;&lt;/div&gt;&lt;h2 id="un-poco-de-gris..."&gt;Un poco de gris...&lt;/h2&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;Ahora, ya sabemos leer y mostrar imágenes. Vamos a operar un poco y a convertir nuestra matriz RGB de entrada en una matriz de intensidades en escala de grises, o en pocas palabras vamos a transformar una matriz de color en una en tono de grises. Para ello vamos a importar el módulo &lt;code style="white-space: pre;"&gt;color&lt;/code&gt; y a utilizar la función &lt;code style="white-space: pre;"&gt;rgb2gray&lt;/code&gt;:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; skimage &lt;span class="im"&gt;import&lt;/span&gt; io,color&lt;br&gt;&lt;br&gt;img &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; io.imread(&lt;span class="st" style="color: #4070a0;"&gt;"lenna.png"&lt;/span&gt;)&lt;br&gt;img_gris &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; color.rgb2gray(img)&lt;br&gt;io.imshow(img_gris)&lt;br&gt;io.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-cpnYBa8KrD4/VqrkUmxJiII/AAAAAAAABtw/5_KMtcD6rb0/s1600/img_02.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="268" src="https://2.bp.blogspot.com/-cpnYBa8KrD4/VqrkUmxJiII/AAAAAAAABtw/5_KMtcD6rb0/s320/img_02.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;¿Y qué pasa si queremos mostrar ambas imágenes en una misma ventana?, bueno, para ello podemos hacer uso de la función &lt;code style="white-space: pre;"&gt;subplot&lt;/code&gt; de Matplotlib:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;span class="im"&gt;from&lt;/span&gt; skimage &lt;span class="im"&gt;import&lt;/span&gt; io,color&lt;br&gt;&lt;br&gt;img &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; io.imread(&lt;span class="st" style="color: #4070a0;"&gt;"lenna.png"&lt;/span&gt;)&lt;br&gt;img_gris &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; color.rgb2gray(img)&lt;br&gt;plt.subplot(&lt;span class="dv" style="color: #40a070;"&gt;211&lt;/span&gt;)&lt;br&gt;io.imshow(img)&lt;br&gt;plt.subplot(&lt;span class="dv" style="color: #40a070;"&gt;212&lt;/span&gt;)&lt;br&gt;io.imshow(img_gris)&lt;br&gt;io.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-i_MssU0Z33c/VqrkRjic1tI/AAAAAAAABto/z0fBVZR3Uis/s1600/img_03.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="268" src="https://2.bp.blogspot.com/-i_MssU0Z33c/VqrkRjic1tI/AAAAAAAABto/z0fBVZR3Uis/s320/img_03.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Hasta aquí esta breve introducción a scikit-image, una librería que sin duda vale la pena revisar y que proporciona una cantidad razonable de algoritmos que pueden ser muy útiles en el procesamiento digital de imágenes. Posteriormente se hablará de algunos tópicos básicos adicionales, como la binarización, segmentación, y otras operaciones típicas.&lt;/div&gt;</description><category>mathjax</category><category>Matplotlib</category><category>PDI</category><category>scikit-image</category><guid>https://numython.github.io/posts/2016/01/introduccion-scikit-image-procesamiento/</guid><pubDate>Fri, 29 Jan 2016 10:06:00 GMT</pubDate></item></channel></rss>