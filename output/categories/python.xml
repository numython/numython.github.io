<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="../assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Numython (python)</title><link>https://numython.github.io/</link><description></description><atom:link href="https://numython.github.io/categories/python.xml" type="application/rss+xml" rel="self"></atom:link><language>es</language><lastBuildDate>Tue, 18 Oct 2016 16:37:09 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Integrales con SymPy</title><link>https://numython.github.io/posts/integrales-con-sympy/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div&gt;&lt;p&gt;Las integrales son uno de los conceptos básicos en la formación matemática de un ingeniero, es en términos básicos la 
operación inversa de la derivación. Pero, además del concepto puramente matemático, las integrales tienen múltiples 
interpretaciones geométricas y físicas.&lt;/p&gt;
&lt;p&gt;En un curso ordinario de cálculo se nos enseñan métodos para resolver de forma analítica funciones que sean integrables. 
Por ejemplo todos sabemos que la integral de una función constante será:&lt;/p&gt;
&lt;p&gt;$$ \int a\,dx = ax + C $$&lt;/p&gt;
&lt;p&gt;Y lo sabemos porque nos hemos aprendido reglas básicas de integración y por supuesto a indentificar el tipo 
de función. Actualmente existen paquetes de álgebra simbólica que son capaces de realizar esta tarea: identificar 
el caso que se tiene y aplicar métodos computacionales, hasta cierto grado complejos, para determinar la solución.&lt;/p&gt;
&lt;p&gt;Y claro, SymPy es uno de esos sistemas de álgebra computacional (CAS), en el que solo necesitamos escribir 
nuestra función a integrar, utilizar por ahí alguna rutina y obtener un resultado rápidamente. Pero claro, 
para ello debemos aprender mínimamente la sintaxis y eso es justo lo que veremos enseguida.&lt;/p&gt;
&lt;h4&gt;Integrales simples&lt;/h4&gt;
&lt;p&gt;Vamos a ver cómo resolver integrales simples indefinidas, si, de esas que vemos en un primer curso. Para resolverlas 
tendremos que utilizar la función &lt;code&gt;ìntegrate&lt;/code&gt;. Por ejemplo se tiene la siguiente función \(f(x)=x^2-3x+2 \).&lt;/p&gt;
&lt;p&gt;Como primer paso debemos importar lo que necesitaremos del paquete SymPy:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Del módulo &lt;code&gt;abc&lt;/code&gt; importamos la variable simbólica &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;ìntegrate&lt;/code&gt; para resolver nuestra integral. Ahora, podemos 
&lt;em&gt;guardar&lt;/em&gt; la función a integrar en una variable o bien pasarla directamente como argumento:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;En este caso no hemos tenido incovenientes, porque en la expresión a integrar sólo existe una variable simbólica, pero 
si la expresión tuviese más de una, habría que especificar de manera explícita la variable respecto a la cual se integra:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"&amp;lt;pyshell#14&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\utilities\decorator.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;threaded_func&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\integrals\integrals.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1228&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;
    &lt;span class="n"&gt;integral&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Integral&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\integrals\integrals.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;__new__&lt;/span&gt;
    &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AddWithLimits&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__new__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;symbols&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;assumptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\concrete\expr_with_limits.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;362&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;__new__&lt;/span&gt;
    &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;specify&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;integrand&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;than&lt;/span&gt; 
&lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;integration&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;supplied&lt;/span&gt; &lt;span class="n"&gt;explicitly&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Pues eso, si intentamos integrar la función \(f(x)=ax^2+bx+c\) sin especificar la variable de integración, Python nos mandará un 
error que es bastante sugerente al respecto. Así, lo correcto sería:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;


&lt;h4&gt;Integrales definidas&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;integrate&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>mathjax</category><category>NumPy</category><category>python</category><guid>https://numython.github.io/posts/integrales-con-sympy/</guid><pubDate>Tue, 18 Oct 2016 16:30:03 GMT</pubDate></item><item><title>NumPy para usuarios de MATLAB</title><link>https://numython.github.io/posts/numpy-para-usuarios-de-matlab/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div&gt;&lt;p&gt;Esta es una traducción/adaptación de &lt;a class="reference external" href="https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html"&gt;Numpy for Matlab users&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="introduccion"&gt;
&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;!-- MATLAB® and NumPy/SciPy have a lot in common. But there are many differences. NumPy and SciPy were created to do numerical and  scientific computing in the most natural way with Python, not to be MATLAB® clones. This page is intended to be a place to collect wisdom about the differences, mostly for the purpose of helping proficient MATLAB® users become proficient NumPy and SciPy users. --&gt;
&lt;p&gt;MATLAB y NumPy/SciPy tienen mucho en común. Pero hay muchas diferencias. NumPy y SciPy fueron creados para
&lt;em&gt;hacer&lt;/em&gt; computación científica y numérica de manera más natural con Python, no como un clon de MATLAB.&lt;/p&gt;
&lt;!-- Some Key Differences --&gt;
&lt;/div&gt;
&lt;div class="section" id="algunas-diferencias-fundamentales"&gt;
&lt;h2&gt;Algunas diferencias fundamentales&lt;/h2&gt;
&lt;!-- In MATLAB®, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra. --&gt;
&lt;p&gt;En MATLAB, el tipo de dato básico es un array multidimensional de precisión doble. La mayoría de las expresiones
toman un array y devuelven justamente el mismo tipo de dato. Las operaciones de arrays bidimensionales están
diseñadas para actuar más o menos como las operaciones matriciales del álgebra lineal.&lt;/p&gt;
&lt;!-- In NumPy the basic type is a multidimensional array. Operations on these arrays in all dimensionalities including 2D are elementwise operations. However, there is a special matrix type for doing linear algebra, which is just a subclass of the array class. Operations on matrix-class arrays are linear algebra operations. --&gt;
&lt;p&gt;En NumPy el tipo básico es un array multidimensional. Las operaciones en estos arrays en todas sus dimensiones,
incluyendo 2D, son operaciones elemento a elemento. Sin embargo, hay un tipo &lt;cite&gt;matrix&lt;/cite&gt; especial para hacer
operaciones de álgebra lineal, el cual es justamente una subclase de la clase &lt;cite&gt;array&lt;/cite&gt;. Las operaciones
en la clase &lt;cite&gt;matrix&lt;/cite&gt; son operaciones de álgebra lineal.&lt;/p&gt;
&lt;!-- MATLAB® uses 1 (one) based indexing. The initial element of a sequence is found using a(1). See note INDEXING --&gt;
&lt;p&gt;MATLAB utiliza indexación basada en 1 (uno). El elemento inicial de la secuencia A se obtiene usando A(1).&lt;/p&gt;
&lt;!-- Python uses 0 (zero) based indexing. The initial element of a sequence is found using a[0]. --&gt;
&lt;p&gt;Python utiliza indexación basada en 0 (cero). El elemento inicial de la secuencia A se obtiene usando A[0].&lt;/p&gt;
&lt;!-- MATLAB®’s scripting language was created for doing linear algebra. The syntax for basic matrix operations is nice and clean, but the API for adding GUIs and making full-fledged applications is more or less an afterthought. --&gt;
&lt;p&gt;El lenguaje de scripting MATLAB fue creado para &lt;em&gt;hacer&lt;/em&gt; algebra lineal. La sintaxis para la mayoría de las operaciones
matriciales básicas es buena y clara, pero la API para agregar una interfaz gráfica y hacer &lt;em&gt;aplicaciones de verdad&lt;/em&gt;
es más o menos una idea adicionada posteriormente y cuya integración es poco fluida.&lt;/p&gt;
&lt;!-- NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab’s syntax for some array manipulations is more compact than NumPy’s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance subclassing the main array type to do both array and matrix math cleanly. --&gt;
&lt;p&gt;NumPy está basado en Python, el cuál fue diseñado desde un inicio para ser un excelente lenguaje de programación
de propósito general. Mientras la sintaxis de MATLAB para algunas manipulaciones de arrays es más compacta
que la de NumPy, NumPy puede hacer muchas cosas que en MATLAB son imposibles, por ejemplo heredar desde el
principal tipo de array (clase &lt;cite&gt;np.ndarray&lt;/cite&gt;) para hacer un tipo &lt;cite&gt;matrix&lt;/cite&gt; que sea más claro para realizar
operaciones de álgebra lineal.&lt;/p&gt;
&lt;!-- In MATLAB®, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array. --&gt;
&lt;p&gt;En MATLAB, los arrays tiene&lt;/p&gt;
&lt;!-- In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array. --&gt;
&lt;p&gt;En NumPy, los arrays&lt;/p&gt;
&lt;!-- ‘array’ or ‘matrix’? Which should I use? --&gt;
&lt;/div&gt;
&lt;div class="section" id="array-o-matrix-cual-deberia-utilizar"&gt;
&lt;h2&gt;¿&lt;cite&gt;array&lt;/cite&gt; o &lt;cite&gt;matrix&lt;/cite&gt;? ¿Cuál debería utilizar?&lt;/h2&gt;
&lt;!-- Numpy provides, in addition to np.ndarray` an additional matrix type that you may see used in some existing code. Which one to use? --&gt;
&lt;p&gt;NumPy proporciona adicionalmente a &lt;cite&gt;np.ndarray&lt;/cite&gt; un tipo &lt;cite&gt;matrix&lt;/cite&gt;, que puede utilizarse en algunas
situaciones, ¿Cuál debo usar?.&lt;/p&gt;
&lt;p&gt;... #### Short answer&lt;/p&gt;
&lt;div class="section" id="respuesta-corta"&gt;
&lt;h3&gt;Respuesta corta&lt;/h3&gt;
&lt;!-- **Use arrays** --&gt;
&lt;p&gt;&lt;strong&gt;Usar el tipo `array`&lt;/strong&gt;&lt;/p&gt;
&lt;!-- &lt;!- - They are the standard vector/matrix/tensor type of numpy. Many numpy function return arrays, not matrices.
There is a clear distinction between element-wise operations and linear algebra operations.
You can have standard vectors or row/column vectors if you like. - -&gt;

&lt;!- - The only disadvantage of using the array type is that you will have to use dot instead of * to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). - -&gt; --&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Es el tipo de matriz/vector estándar de NumPy. Muchas funciones de NumPy devuelven un array, no matrices.&lt;/li&gt;
&lt;li&gt;Hay una distinción clara entre las operaciones elemento a elemento y las de álgebra lineal.&lt;/li&gt;
&lt;li&gt;Puede tener vectores estándar o vectores filas/columnas si lo requiere.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La única desventaja de usar el tipo array es que tendrás que utilizar la función/método &lt;cite&gt;dot&lt;/cite&gt; en lugar de &lt;cite&gt;*&lt;/cite&gt; para
multiplicar dos tensores (producto escalar, multiplicación matricial,...)&lt;/p&gt;
&lt;!-- #### Long answer --&gt;
&lt;/div&gt;
&lt;div class="section" id="respuesta-larga"&gt;
&lt;h3&gt;Respuesta larga&lt;/h3&gt;
&lt;!-- Numpy contains both an array class and a matrix class. The array class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while matrix is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two. --&gt;
&lt;p&gt;NumPy contiene una clase &lt;cite&gt;array&lt;/cite&gt; y una clase &lt;cite&gt;matrix&lt;/cite&gt;. La clase &lt;cite&gt;array&lt;/cite&gt; tiene la finalidad de ser un
array n-dimensional de propósito general para muchos tipos de computación numérica, mientras la
clase &lt;cite&gt;matrix&lt;/cite&gt; tiene la finalidad de facilitar especificamente cuestiones relacionadas con la
computación del álgebra lineal. En la práctica, sólo hay un puñado de diferencias claves
entre ambas:&lt;/p&gt;
&lt;!-- &lt;!- - Operator *, dot(), and multiply():
For array, ‘``*``’ means element-wise multiplication, and the dot() function is used for matrix multiplication.
For matrix, ‘``*``’ means matrix multiplication, and the multiply() function is used for element-wise multiplication. - -&gt;

* Operator `*`, `dot()`, and `multiply()`:
    - Para array - - -
    - Para matrix

Handling of vectors (rank-1 arrays)
For array, the vector shapes 1xN, Nx1, and N are all different things. Operations like A[:,1] return a rank-1 array of shape N, not a rank-2 of shape Nx1. Transpose on a rank-1 array does nothing.
For matrix, rank-1 arrays are always upconverted to 1xN or Nx1 matrices (row or column vectors). A[:,1] returns a rank-2 matrix of shape Nx1.
Handling of higher-rank arrays (rank &gt; 2)
array objects can have rank &gt; 2.
matrix objects always have exactly rank 2.
Convenience attributes
array has a .T attribute, which returns the transpose of the data.
matrix also has .H, .I, and .A attributes, which return the conjugate transpose, inverse, and asarray() of the matrix, respectively.
Convenience constructor
The array constructor takes (nested) Python sequences as initializers. As in, array([[1,2,3],[4,5,6]]).
The matrix constructor additionally takes a convenient string initializer. As in matrix("[1 2 3; 4 5 6]").
There are pros and cons to using both:

array
:) You can treat rank-1 arrays as either row or column vectors. dot(A,v) treats v as a column vector, while dot(v,A) treats v as a row vector. This can save you having to type a lot of transposes.
&lt;:( Having to use the dot() function for matrix-multiply is messy – dot(dot(A,B),C) vs. A*B*C.
:) Element-wise multiplication is easy: A*B.
:) array is the “default” NumPy type, so it gets the most testing, and is the type most likely to be returned by 3rd party code that uses NumPy.
:) Is quite at home handling data of any rank.
:) Closer in semantics to tensor algebra, if you are familiar with that.
:) All operations (*, /, +, ```` etc.) are elementwise
matrix
:\\ Behavior is more like that of MATLAB® matrices.
&lt;:( Maximum of rank-2. To hold rank-3 data you need array or perhaps a Python list of matrix.
&lt;:( Minimum of rank-2. You cannot have vectors. They must be cast as single-column or single-row matrices.
&lt;:( Since array is the default in NumPy, some functions may return an array even if you give them a matrix as an argument. This shouldn’t happen with NumPy functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor type preservation like NumPy does.
:) A*B is matrix multiplication, so more convenient for linear algebra.
&lt;:( Element-wise multiplication requires calling a function, multipy(A,B).
&lt;:( The use of operator overloading is a bit illogical: * does not work elementwise but / does.
The array is thus much more advisable to use.

### Facilities for Matrix Users
Numpy has some features that facilitate the use of the matrix type, which hopefully make things easier for Matlab converts.

A matlib module has been added that contains matrix versions of common array constructors like ones(), zeros(), empty(), eye(), rand(), repmat(), etc. Normally these functions return arrays, but the matlib versions return matrix objects.
mat has been changed to be a synonym for asmatrix, rather than matrix, thus making it concise way to convert an array to a matrix without copying the data.
Some top-level functions have been removed. For example numpy.rand() now needs to be accessed as numpy.random.rand(). Or use the rand() from the matlib module. But the “numpythonic” way is to use numpy.random.random(), which takes a tuple for the shape, like other numpy functions.
Table of Rough MATLAB-NumPy Equivalents
The table below gives rough equivalents for some common MATLAB® expressions. These are not exact equivalents, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.

Some care is necessary when writing functions that take arrays or matrices as arguments — if you are expecting an array and are given a matrix, or vice versa, then ‘*’ (multiplication) will give you unexpected results. You can convert back and forth between arrays and matrices using

asarray: always returns an object of type array
asmatrix or mat: always return an object of type matrix
asanyarray: always returns an array object or a subclass derived from it, depending on the input. For instance if you pass in a matrix it returns a matrix.
These functions all accept both arrays and matrices (among other things like Python lists), and thus are useful when writing functions that should accept any array-like object.

In the table below, it is assumed that you have executed the following commands in Python:

from numpy import *
import scipy.linalg
Also assume below that if the Notes talk about “matrix” that the arguments are rank 2 entities.

General Purpose Equivalents

MATLAB  numpy   Notes
help func   info(func) or help(func) or func? (in Ipython)  get help on the function func
which func  see note HELP   find out where func is defined
type func   source(func) or func?? (in Ipython) print source for func (if not a native function)
a &amp;&amp; b  a and b short-circuiting logical AND operator (Python native operator); scalar arguments only
a || b  a or b  short-circuiting logical OR operator (Python native operator); scalar arguments only
1*i, 1*j, 1i, 1j    1j  complex numbers
eps np.spacing(1)   Distance between 1 and the nearest floating point number
ode45   scipy.integrate.ode(f).set_integrator('dopri5') integrate an ODE with Runge-Kutta 4,5
ode15s  scipy.integrate.ode(f).set_integrator('vode', method='bdf', order=15)   integrate an ODE with BDF method
Linear Algebra Equivalents

MATLAB  NumPy   Notes
ndims(a)    ndim(a) or a.ndim   get the number of dimensions of a (tensor rank)
numel(a)    size(a) or a.size   get the number of elements of an array
size(a) shape(a) or a.shape get the “size” of the matrix
size(a,n)   a.shape[n-1]    get the number of elements of the n-th dimension of array a. (Note that MATLAB® uses 1 based indexing while Python uses 0 based indexing, See note INDEXING)
[ 1 2 3; 4 5 6 ]    array([[1.,2.,3.], [4.,5.,6.]]) 2x3 matrix literal
[ a b; c d ]    vstack([hstack([a,b]), hstack([c,d])]) or bmat('a b; c d').A    construct a matrix from blocks a,b,c, and d
a(end)  a[-1]   access last element in the 1xn matrix a
a(2,5)  a[1,4]  access element in second row, fifth column
a(2,:)  a[1] or a[1,:]  entire second row of a
a(1:5,:)    a[0:5] or a[:5] or a[0:5,:] the first five rows of a
a(end-4:end,:)  a[-5:]  the last five rows of a
a(1:3,5:9)  a[0:3][:,4:9]   rows one to three and columns five to nine of a. This gives read-only access.
a([2,4,5],[1,3])    a[ix_([1,3,4],[0,2])]   rows 2,4 and 5 and columns 1 and 3. This allows the matrix to be modified, and doesn’t require a regular slice.
a(3:2:21,:) a[ 2:21:2,:]    every other row of a, starting with the third and going to the twenty-first
a(1:2:end,:)    a[ ::2,:]   every other row of a, starting with the first
a(end:-1:1,:) or flipud(a)  a[ ::-1,:]  a with rows in reverse order
a([1:end 1],:)  a[r_[:len(a),0]]    a with copy of the first row appended to the end
a.' a.transpose() or a.T    transpose of a
a'  a.conj().transpose() or a.conj().T  conjugate transpose of a
a * b   a.dot(b)    matrix multiply
a .* b  a * b   element-wise multiply
a./b    a/b element-wise divide
a.^3    a**3    element-wise exponentiation
(a&gt;0.5) (a&gt;0.5) matrix whose i,jth element is (a_ij &gt; 0.5)
find(a&gt;0.5) nonzero(a&gt;0.5)  find the indices where (a &gt; 0.5)
a(:,find(v&gt;0.5))    a[:,nonzero(v&gt;0.5)[0]]  extract the columms of a where vector v &gt; 0.5
a(:,find(v&gt;0.5))    a[:,v.T&gt;0.5]    extract the columms of a where column vector v &gt; 0.5
a(a&lt;0.5)=0  a[a&lt;0.5]=0  a with elements less than 0.5 zeroed out
a .* (a&gt;0.5)    a * (a&gt;0.5) a with elements less than 0.5 zeroed out
a(:) = 3    a[:] = 3    set all values to the same scalar value
y=x y = x.copy()    numpy assigns by reference
y=x(2,:)    y = x[1,:].copy()   numpy slices are by reference
y=x(:)  y = x.flatten(1)    turn array into vector (note that this forces a copy)
1:10    arange(1.,11.) or r_[1.:11.] or r_[1:10:10j]    create an increasing vector (see note RANGES)
0:9 arange(10.) or r_[:10.] or r_[:9:10j]   create an increasing vector (see note RANGES)
[1:10]' arange(1.,11.)[:, newaxis]  create a column vector
zeros(3,4)  zeros((3,4))    3x4 rank-2 array full of 64-bit floating point zeros
zeros(3,4,5)    zeros((3,4,5))  3x4x5 rank-3 array full of 64-bit floating point zeros
ones(3,4)   ones((3,4)) 3x4 rank-2 array full of 64-bit floating point ones
eye(3)  eye(3)  3x3 identity matrix
diag(a) diag(a) vector of diagonal elements of a
diag(a,0)   diag(a,0)   square diagonal matrix whose nonzero values are the elements of a
rand(3,4)   random.rand(3,4)    random 3x4 matrix
linspace(1,3,4) linspace(1,3,4) 4 equally spaced samples between 1 and 3, inclusive
[x,y]=meshgrid(0:8,0:5) mgrid[0:9.,0:6.] or meshgrid(r_[0:9.],r_[0:6.]  two 2D arrays: one of x values, the other of y values
    ogrid[0:9.,0:6.] or ix_(r_[0:9.],r_[0:6.]   the best way to eval functions on a grid
[x,y]=meshgrid([1,2,4],[2,4,5]) meshgrid([1,2,4],[2,4,5])
    ix_([1,2,4],[2,4,5])    the best way to eval functions on a grid
repmat(a, m, n) tile(a, (m, n)) create m by n copies of a
[a b]   concatenate((a,b),1) or hstack((a,b)) or column_stack((a,b)) or c_[a,b] concatenate columns of a and b
[a; b]  concatenate((a,b)) or vstack((a,b)) or r_[a,b]  concatenate rows of a and b
max(max(a)) a.max() maximum element of a (with ndims(a)&lt;=2 for matlab)
max(a)  a.max(0)    maximum element of each column of matrix a
max(a,[],2) a.max(1)    maximum element of each row of matrix a
max(a,b)    maximum(a, b)   compares a and b element-wise, and returns the maximum value from each pair
norm(v) sqrt(dot(v,v)) or np.linalg.norm(v) L2 norm of vector v
a &amp; b   logical_and(a,b)    element-by-element AND operator (Numpy ufunc) See note LOGICOPS
a | b   logical_or(a,b) element-by-element OR operator (Numpy ufunc) See note LOGICOPS
bitand(a,b) a &amp; b   bitwise AND operator (Python native and Numpy ufunc)
bitor(a,b)  a | b   bitwise OR operator (Python native and Numpy ufunc)
inv(a)  linalg.inv(a)   inverse of square matrix a
pinv(a) linalg.pinv(a)  pseudo-inverse of matrix a
rank(a) linalg.matrix_rank(a)   rank of a matrix a
a\b linalg.solve(a,b) if a is square; linalg.lstsq(a,b) otherwise   solution of a x = b for x
b/a Solve a.T x.T = b.T instead solution of x a = b for x
[U,S,V]=svd(a)  U, S, Vh = linalg.svd(a), V = Vh.T  singular value decomposition of a
chol(a) linalg.cholesky(a).T    cholesky factorization of a matrix (chol(a) in matlab returns an upper triangular matrix, but linalg.cholesky(a) returns a lower triangular matrix)
[V,D]=eig(a)    D,V = linalg.eig(a) eigenvalues and eigenvectors of a
[V,D]=eig(a,b)  V,D = np.linalg.eig(a,b)    eigenvalues and eigenvectors of a,b
[V,D]=eigs(a,k)     find the k largest eigenvalues and eigenvectors of a
[Q,R,P]=qr(a,0) Q,R = scipy.linalg.qr(a)    QR decomposition
[L,U,P]=lu(a)   L,U = scipy.linalg.lu(a) or LU,P=scipy.linalg.lu_factor(a)  LU decomposition (note: P(Matlab) == transpose(P(numpy)) )
conjgrad    scipy.sparse.linalg.cg  Conjugate gradients solver
fft(a)  fft(a)  Fourier transform of a
ifft(a) ifft(a) inverse Fourier transform of a
sort(a) sort(a) or a.sort() sort the matrix
[b,I] = sortrows(a,i)   I = argsort(a[:,i]), b=a[I,:]   sort the rows of the matrix
regress(y,X)    linalg.lstsq(X,y)   multilinear regression
decimate(x, q)  scipy.signal.resample(x, len(x)/q)  downsample with low-pass filtering
unique(a)   unique(a)
squeeze(a)  a.squeeze()
Notes
Submatrix: Assignment to a submatrix can be done with lists of indexes using the ix_ command. E.g., for 2d array a, one might do: ind=[1,3]; a[np.ix_(ind,ind)]+=100.

HELP: There is no direct equivalent of MATLAB’s which command, but the commands help and source will usually list the filename where the function is located. Python also has an inspect module (do import inspect) which provides a getfile that often works.

INDEXING: MATLAB® uses one based indexing, so the initial element of a sequence has index 1. Python uses zero based indexing, so the initial element of a sequence has index 0. Confusion and flamewars arise because each has advantages and disadvantages. One based indexing is consistent with common human language usage, where the “first” element of a sequence has index 1. Zero based indexing simplifies indexing. See also a text by prof.dr. Edsger W. Dijkstra.

RANGES: In MATLAB®, 0:5 can be used as both a range literal and a ‘slice’ index (inside parentheses); however, in Python, constructs like 0:5 can only be used as a slice index (inside square brackets). Thus the somewhat quirky r_ object was created to allow numpy to have a similarly terse range construction mechanism. Note that r_ is not called like a function or a constructor, but rather indexed using square brackets, which allows the use of Python’s slice syntax in the arguments.

LOGICOPS: &amp; or | in Numpy is bitwise AND/OR, while in Matlab &amp; and | are logical AND/OR. The difference should be clear to anyone with significant programming experience. The two can appear to work the same, but there are important differences. If you would have used Matlab’s &amp; or | operators, you should use the Numpy ufuncs logical_and/logical_or. The notable differences between Matlab’s and Numpy’s &amp; and | operators are:

Non-logical {0,1} inputs: Numpy’s output is the bitwise AND of the inputs. Matlab treats any non-zero value as 1 and returns the logical AND. For example (3 &amp; 4) in Numpy is 0, while in Matlab both 3 and 4 are considered logical true and (3 &amp; 4) returns 1.
Precedence: Numpy’s &amp; operator is higher precedence than logical operators like &lt; and &gt;; Matlab’s is the reverse.
If you know you have boolean arguments, you can get away with using Numpy’s bitwise operators, but be careful with parentheses, like this: z = (x &gt; 1) &amp; (x &lt; 2). The absence of Numpy operator forms of logical_and and logical_or is an unfortunate consequence of Python’s design.

RESHAPE and LINEAR INDEXING: Matlab always allows multi-dimensional arrays to be accessed using scalar or linear indices, Numpy does not. Linear indices are common in Matlab programs, e.g. find() on a matrix returns them, whereas Numpy’s find behaves differently. When converting Matlab code it might be necessary to first reshape a matrix to a linear sequence, perform some indexing operations and then reshape back. As reshape (usually) produces views onto the same storage, it should be possible to do this fairly efficiently. Note that the scan order used by reshape in Numpy defaults to the ‘C’ order, whereas Matlab uses the Fortran order. If you are simply converting to a linear sequence and back this doesn’t matter. But if you are converting reshapes from Matlab code which relies on the scan order, then this Matlab code: z = reshape(x,3,4); should become z = x.reshape(3,4,order=’F’).copy() in Numpy.

Customizing Your Environment
In MATLAB® the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.

NumPy, or rather Python, has similar facilities.

To modify your Python search path to include the locations of your own modules, define the PYTHONPATH environment variable.
To have a particular script file executed when the interactive Python interpreter is started, define the PYTHONSTARTUP environment variable to contain the name of your startup script.
Unlike MATLAB®, where anything on your path can be called immediately, with Python you need to first do an ‘import’ statement to make functions in a particular file accessible.

For example you might make a startup script that looks like this (Note: this is just an example, not a statement of “best practices”):

# Make all numpy available via shorter 'num' prefix
import numpy as num
# Make all matlib functions accessible at the top level via M.func()
import numpy.matlib as M
# Make some matlib functions accessible directly at the top level via, e.g. rand(3,3)
from numpy.matlib import rand,zeros,ones,empty,eye
# Define a Hermitian function
def hermitian(A, **kwargs):
    return num.transpose(A,**kwargs).conj()
# Make some shorcuts for transpose,hermitian:
#    num.transpose(A) - -&gt; T(A)
#    hermitian(A) - -&gt; H(A)
T = num.transpose
H = hermitian
Links
See http://mathesaurus.sf.net/ for another MATLAB®/NumPy cross-reference.

An extensive list of tools for scientific work with python can be found in the topical software page.

MATLAB® and SimuLink® are registered trademarks of The MathWorks. --&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>mathjax</category><category>MATLAB</category><category>NumPy</category><category>python</category><guid>https://numython.github.io/posts/numpy-para-usuarios-de-matlab/</guid><pubDate>Tue, 18 Oct 2016 15:58:03 GMT</pubDate></item></channel></rss>