<?xml version="1.0" encoding="utf-8"?>
<?xml-stylesheet type="text/xsl" href="assets/xml/rss.xsl" media="all"?><rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Numython</title><link>https://numython.github.io/</link><description>Python para ingenieros</description><atom:link href="https://numython.github.io/rss.xml" type="application/rss+xml" rel="self"></atom:link><language>es</language><lastBuildDate>Tue, 18 Oct 2016 16:37:09 GMT</lastBuildDate><generator>https://getnikola.com/</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>Integrales con SymPy</title><link>https://numython.github.io/posts/integrales-con-sympy/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div&gt;&lt;p&gt;Las integrales son uno de los conceptos básicos en la formación matemática de un ingeniero, es en términos básicos la 
operación inversa de la derivación. Pero, además del concepto puramente matemático, las integrales tienen múltiples 
interpretaciones geométricas y físicas.&lt;/p&gt;
&lt;p&gt;En un curso ordinario de cálculo se nos enseñan métodos para resolver de forma analítica funciones que sean integrables. 
Por ejemplo todos sabemos que la integral de una función constante será:&lt;/p&gt;
&lt;p&gt;$$ \int a\,dx = ax + C $$&lt;/p&gt;
&lt;p&gt;Y lo sabemos porque nos hemos aprendido reglas básicas de integración y por supuesto a indentificar el tipo 
de función. Actualmente existen paquetes de álgebra simbólica que son capaces de realizar esta tarea: identificar 
el caso que se tiene y aplicar métodos computacionales, hasta cierto grado complejos, para determinar la solución.&lt;/p&gt;
&lt;p&gt;Y claro, SymPy es uno de esos sistemas de álgebra computacional (CAS), en el que solo necesitamos escribir 
nuestra función a integrar, utilizar por ahí alguna rutina y obtener un resultado rápidamente. Pero claro, 
para ello debemos aprender mínimamente la sintaxis y eso es justo lo que veremos enseguida.&lt;/p&gt;
&lt;h4&gt;Integrales simples&lt;/h4&gt;
&lt;p&gt;Vamos a ver cómo resolver integrales simples indefinidas, si, de esas que vemos en un primer curso. Para resolverlas 
tendremos que utilizar la función &lt;code&gt;ìntegrate&lt;/code&gt;. Por ejemplo se tiene la siguiente función \(f(x)=x^2-3x+2 \).&lt;/p&gt;
&lt;p&gt;Como primer paso debemos importar lo que necesitaremos del paquete SymPy:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Del módulo &lt;code&gt;abc&lt;/code&gt; importamos la variable simbólica &lt;code&gt;x&lt;/code&gt; e &lt;code&gt;ìntegrate&lt;/code&gt; para resolver nuestra integral. Ahora, podemos 
&lt;em&gt;guardar&lt;/em&gt; la función a integrar en una variable o bien pasarla directamente como argumento:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;En este caso no hemos tenido incovenientes, porque en la expresión a integrar sólo existe una variable simbólica, pero 
si la expresión tuviese más de una, habría que especificar de manera explícita la variable respecto a la cual se integra:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"&amp;lt;pyshell#14&amp;gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\utilities\decorator.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;35&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;threaded_func&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;expr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\integrals\integrals.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1228&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;
    &lt;span class="n"&gt;integral&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Integral&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\integrals\integrals.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;79&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;__new__&lt;/span&gt;
    &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AddWithLimits&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;__new__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cls&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;symbols&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;assumptions&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;"C:\Python27\lib\site-packages\sympy\concrete\expr_with_limits.py"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;362&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;__new__&lt;/span&gt;
    &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;  &lt;span class="n"&gt;specify&lt;/span&gt; &lt;span class="n"&gt;dummy&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;integrand&lt;/span&gt; &lt;span class="n"&gt;contains&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;than&lt;/span&gt; 
&lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;free&lt;/span&gt; &lt;span class="n"&gt;symbol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;integration&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;should&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;supplied&lt;/span&gt; &lt;span class="n"&gt;explicitly&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;g&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;


&lt;p&gt;Pues eso, si intentamos integrar la función \(f(x)=ax^2+bx+c\) sin especificar la variable de integración, Python nos mandará un 
error que es bastante sugerente al respecto. Así, lo correcto sería:&lt;/p&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;
&lt;/pre&gt;


&lt;h4&gt;Integrales definidas&lt;/h4&gt;
&lt;pre class="code literal-block"&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy.abc&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;sympy&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;integrate&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;integrate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;),(&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;pi&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><category>mathjax</category><category>NumPy</category><category>python</category><guid>https://numython.github.io/posts/integrales-con-sympy/</guid><pubDate>Tue, 18 Oct 2016 16:30:03 GMT</pubDate></item><item><title>NumPy para usuarios de MATLAB</title><link>https://numython.github.io/posts/numpy-para-usuarios-de-matlab/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div&gt;&lt;p&gt;Esta es una traducción/adaptación de &lt;a class="reference external" href="https://docs.scipy.org/doc/numpy-dev/user/numpy-for-matlab-users.html"&gt;Numpy for Matlab users&lt;/a&gt;.&lt;/p&gt;
&lt;div class="section" id="introduccion"&gt;
&lt;h2&gt;Introducción&lt;/h2&gt;
&lt;!-- MATLAB® and NumPy/SciPy have a lot in common. But there are many differences. NumPy and SciPy were created to do numerical and  scientific computing in the most natural way with Python, not to be MATLAB® clones. This page is intended to be a place to collect wisdom about the differences, mostly for the purpose of helping proficient MATLAB® users become proficient NumPy and SciPy users. --&gt;
&lt;p&gt;MATLAB y NumPy/SciPy tienen mucho en común. Pero hay muchas diferencias. NumPy y SciPy fueron creados para
&lt;em&gt;hacer&lt;/em&gt; computación científica y numérica de manera más natural con Python, no como un clon de MATLAB.&lt;/p&gt;
&lt;!-- Some Key Differences --&gt;
&lt;/div&gt;
&lt;div class="section" id="algunas-diferencias-fundamentales"&gt;
&lt;h2&gt;Algunas diferencias fundamentales&lt;/h2&gt;
&lt;!-- In MATLAB®, the basic data type is a multidimensional array of double precision floating point numbers. Most expressions take such arrays and return such arrays. Operations on the 2-D instances of these arrays are designed to act more or less like matrix operations in linear algebra. --&gt;
&lt;p&gt;En MATLAB, el tipo de dato básico es un array multidimensional de precisión doble. La mayoría de las expresiones
toman un array y devuelven justamente el mismo tipo de dato. Las operaciones de arrays bidimensionales están
diseñadas para actuar más o menos como las operaciones matriciales del álgebra lineal.&lt;/p&gt;
&lt;!-- In NumPy the basic type is a multidimensional array. Operations on these arrays in all dimensionalities including 2D are elementwise operations. However, there is a special matrix type for doing linear algebra, which is just a subclass of the array class. Operations on matrix-class arrays are linear algebra operations. --&gt;
&lt;p&gt;En NumPy el tipo básico es un array multidimensional. Las operaciones en estos arrays en todas sus dimensiones,
incluyendo 2D, son operaciones elemento a elemento. Sin embargo, hay un tipo &lt;cite&gt;matrix&lt;/cite&gt; especial para hacer
operaciones de álgebra lineal, el cual es justamente una subclase de la clase &lt;cite&gt;array&lt;/cite&gt;. Las operaciones
en la clase &lt;cite&gt;matrix&lt;/cite&gt; son operaciones de álgebra lineal.&lt;/p&gt;
&lt;!-- MATLAB® uses 1 (one) based indexing. The initial element of a sequence is found using a(1). See note INDEXING --&gt;
&lt;p&gt;MATLAB utiliza indexación basada en 1 (uno). El elemento inicial de la secuencia A se obtiene usando A(1).&lt;/p&gt;
&lt;!-- Python uses 0 (zero) based indexing. The initial element of a sequence is found using a[0]. --&gt;
&lt;p&gt;Python utiliza indexación basada en 0 (cero). El elemento inicial de la secuencia A se obtiene usando A[0].&lt;/p&gt;
&lt;!-- MATLAB®’s scripting language was created for doing linear algebra. The syntax for basic matrix operations is nice and clean, but the API for adding GUIs and making full-fledged applications is more or less an afterthought. --&gt;
&lt;p&gt;El lenguaje de scripting MATLAB fue creado para &lt;em&gt;hacer&lt;/em&gt; algebra lineal. La sintaxis para la mayoría de las operaciones
matriciales básicas es buena y clara, pero la API para agregar una interfaz gráfica y hacer &lt;em&gt;aplicaciones de verdad&lt;/em&gt;
es más o menos una idea adicionada posteriormente y cuya integración es poco fluida.&lt;/p&gt;
&lt;!-- NumPy is based on Python, which was designed from the outset to be an excellent general-purpose programming language. While Matlab’s syntax for some array manipulations is more compact than NumPy’s, NumPy (by virtue of being an add-on to Python) can do many things that Matlab just cannot, for instance subclassing the main array type to do both array and matrix math cleanly. --&gt;
&lt;p&gt;NumPy está basado en Python, el cuál fue diseñado desde un inicio para ser un excelente lenguaje de programación
de propósito general. Mientras la sintaxis de MATLAB para algunas manipulaciones de arrays es más compacta
que la de NumPy, NumPy puede hacer muchas cosas que en MATLAB son imposibles, por ejemplo heredar desde el
principal tipo de array (clase &lt;cite&gt;np.ndarray&lt;/cite&gt;) para hacer un tipo &lt;cite&gt;matrix&lt;/cite&gt; que sea más claro para realizar
operaciones de álgebra lineal.&lt;/p&gt;
&lt;!-- In MATLAB®, arrays have pass-by-value semantics, with a lazy copy-on-write scheme to prevent actually creating copies until they are actually needed. Slice operations copy parts of the array. --&gt;
&lt;p&gt;En MATLAB, los arrays tiene&lt;/p&gt;
&lt;!-- In NumPy arrays have pass-by-reference semantics. Slice operations are views into an array. --&gt;
&lt;p&gt;En NumPy, los arrays&lt;/p&gt;
&lt;!-- ‘array’ or ‘matrix’? Which should I use? --&gt;
&lt;/div&gt;
&lt;div class="section" id="array-o-matrix-cual-deberia-utilizar"&gt;
&lt;h2&gt;¿&lt;cite&gt;array&lt;/cite&gt; o &lt;cite&gt;matrix&lt;/cite&gt;? ¿Cuál debería utilizar?&lt;/h2&gt;
&lt;!-- Numpy provides, in addition to np.ndarray` an additional matrix type that you may see used in some existing code. Which one to use? --&gt;
&lt;p&gt;NumPy proporciona adicionalmente a &lt;cite&gt;np.ndarray&lt;/cite&gt; un tipo &lt;cite&gt;matrix&lt;/cite&gt;, que puede utilizarse en algunas
situaciones, ¿Cuál debo usar?.&lt;/p&gt;
&lt;p&gt;... #### Short answer&lt;/p&gt;
&lt;div class="section" id="respuesta-corta"&gt;
&lt;h3&gt;Respuesta corta&lt;/h3&gt;
&lt;!-- **Use arrays** --&gt;
&lt;p&gt;&lt;strong&gt;Usar el tipo `array`&lt;/strong&gt;&lt;/p&gt;
&lt;!-- &lt;!- - They are the standard vector/matrix/tensor type of numpy. Many numpy function return arrays, not matrices.
There is a clear distinction between element-wise operations and linear algebra operations.
You can have standard vectors or row/column vectors if you like. - -&gt;

&lt;!- - The only disadvantage of using the array type is that you will have to use dot instead of * to multiply (reduce) two tensors (scalar product, matrix vector multiplication etc.). - -&gt; --&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Es el tipo de matriz/vector estándar de NumPy. Muchas funciones de NumPy devuelven un array, no matrices.&lt;/li&gt;
&lt;li&gt;Hay una distinción clara entre las operaciones elemento a elemento y las de álgebra lineal.&lt;/li&gt;
&lt;li&gt;Puede tener vectores estándar o vectores filas/columnas si lo requiere.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La única desventaja de usar el tipo array es que tendrás que utilizar la función/método &lt;cite&gt;dot&lt;/cite&gt; en lugar de &lt;cite&gt;*&lt;/cite&gt; para
multiplicar dos tensores (producto escalar, multiplicación matricial,...)&lt;/p&gt;
&lt;!-- #### Long answer --&gt;
&lt;/div&gt;
&lt;div class="section" id="respuesta-larga"&gt;
&lt;h3&gt;Respuesta larga&lt;/h3&gt;
&lt;!-- Numpy contains both an array class and a matrix class. The array class is intended to be a general-purpose n-dimensional array for many kinds of numerical computing, while matrix is intended to facilitate linear algebra computations specifically. In practice there are only a handful of key differences between the two. --&gt;
&lt;p&gt;NumPy contiene una clase &lt;cite&gt;array&lt;/cite&gt; y una clase &lt;cite&gt;matrix&lt;/cite&gt;. La clase &lt;cite&gt;array&lt;/cite&gt; tiene la finalidad de ser un
array n-dimensional de propósito general para muchos tipos de computación numérica, mientras la
clase &lt;cite&gt;matrix&lt;/cite&gt; tiene la finalidad de facilitar especificamente cuestiones relacionadas con la
computación del álgebra lineal. En la práctica, sólo hay un puñado de diferencias claves
entre ambas:&lt;/p&gt;
&lt;!-- &lt;!- - Operator *, dot(), and multiply():
For array, ‘``*``’ means element-wise multiplication, and the dot() function is used for matrix multiplication.
For matrix, ‘``*``’ means matrix multiplication, and the multiply() function is used for element-wise multiplication. - -&gt;

* Operator `*`, `dot()`, and `multiply()`:
    - Para array - - -
    - Para matrix

Handling of vectors (rank-1 arrays)
For array, the vector shapes 1xN, Nx1, and N are all different things. Operations like A[:,1] return a rank-1 array of shape N, not a rank-2 of shape Nx1. Transpose on a rank-1 array does nothing.
For matrix, rank-1 arrays are always upconverted to 1xN or Nx1 matrices (row or column vectors). A[:,1] returns a rank-2 matrix of shape Nx1.
Handling of higher-rank arrays (rank &gt; 2)
array objects can have rank &gt; 2.
matrix objects always have exactly rank 2.
Convenience attributes
array has a .T attribute, which returns the transpose of the data.
matrix also has .H, .I, and .A attributes, which return the conjugate transpose, inverse, and asarray() of the matrix, respectively.
Convenience constructor
The array constructor takes (nested) Python sequences as initializers. As in, array([[1,2,3],[4,5,6]]).
The matrix constructor additionally takes a convenient string initializer. As in matrix("[1 2 3; 4 5 6]").
There are pros and cons to using both:

array
:) You can treat rank-1 arrays as either row or column vectors. dot(A,v) treats v as a column vector, while dot(v,A) treats v as a row vector. This can save you having to type a lot of transposes.
&lt;:( Having to use the dot() function for matrix-multiply is messy – dot(dot(A,B),C) vs. A*B*C.
:) Element-wise multiplication is easy: A*B.
:) array is the “default” NumPy type, so it gets the most testing, and is the type most likely to be returned by 3rd party code that uses NumPy.
:) Is quite at home handling data of any rank.
:) Closer in semantics to tensor algebra, if you are familiar with that.
:) All operations (*, /, +, ```` etc.) are elementwise
matrix
:\\ Behavior is more like that of MATLAB® matrices.
&lt;:( Maximum of rank-2. To hold rank-3 data you need array or perhaps a Python list of matrix.
&lt;:( Minimum of rank-2. You cannot have vectors. They must be cast as single-column or single-row matrices.
&lt;:( Since array is the default in NumPy, some functions may return an array even if you give them a matrix as an argument. This shouldn’t happen with NumPy functions (if it does it’s a bug), but 3rd party code based on NumPy may not honor type preservation like NumPy does.
:) A*B is matrix multiplication, so more convenient for linear algebra.
&lt;:( Element-wise multiplication requires calling a function, multipy(A,B).
&lt;:( The use of operator overloading is a bit illogical: * does not work elementwise but / does.
The array is thus much more advisable to use.

### Facilities for Matrix Users
Numpy has some features that facilitate the use of the matrix type, which hopefully make things easier for Matlab converts.

A matlib module has been added that contains matrix versions of common array constructors like ones(), zeros(), empty(), eye(), rand(), repmat(), etc. Normally these functions return arrays, but the matlib versions return matrix objects.
mat has been changed to be a synonym for asmatrix, rather than matrix, thus making it concise way to convert an array to a matrix without copying the data.
Some top-level functions have been removed. For example numpy.rand() now needs to be accessed as numpy.random.rand(). Or use the rand() from the matlib module. But the “numpythonic” way is to use numpy.random.random(), which takes a tuple for the shape, like other numpy functions.
Table of Rough MATLAB-NumPy Equivalents
The table below gives rough equivalents for some common MATLAB® expressions. These are not exact equivalents, but rather should be taken as hints to get you going in the right direction. For more detail read the built-in documentation on the NumPy functions.

Some care is necessary when writing functions that take arrays or matrices as arguments — if you are expecting an array and are given a matrix, or vice versa, then ‘*’ (multiplication) will give you unexpected results. You can convert back and forth between arrays and matrices using

asarray: always returns an object of type array
asmatrix or mat: always return an object of type matrix
asanyarray: always returns an array object or a subclass derived from it, depending on the input. For instance if you pass in a matrix it returns a matrix.
These functions all accept both arrays and matrices (among other things like Python lists), and thus are useful when writing functions that should accept any array-like object.

In the table below, it is assumed that you have executed the following commands in Python:

from numpy import *
import scipy.linalg
Also assume below that if the Notes talk about “matrix” that the arguments are rank 2 entities.

General Purpose Equivalents

MATLAB  numpy   Notes
help func   info(func) or help(func) or func? (in Ipython)  get help on the function func
which func  see note HELP   find out where func is defined
type func   source(func) or func?? (in Ipython) print source for func (if not a native function)
a &amp;&amp; b  a and b short-circuiting logical AND operator (Python native operator); scalar arguments only
a || b  a or b  short-circuiting logical OR operator (Python native operator); scalar arguments only
1*i, 1*j, 1i, 1j    1j  complex numbers
eps np.spacing(1)   Distance between 1 and the nearest floating point number
ode45   scipy.integrate.ode(f).set_integrator('dopri5') integrate an ODE with Runge-Kutta 4,5
ode15s  scipy.integrate.ode(f).set_integrator('vode', method='bdf', order=15)   integrate an ODE with BDF method
Linear Algebra Equivalents

MATLAB  NumPy   Notes
ndims(a)    ndim(a) or a.ndim   get the number of dimensions of a (tensor rank)
numel(a)    size(a) or a.size   get the number of elements of an array
size(a) shape(a) or a.shape get the “size” of the matrix
size(a,n)   a.shape[n-1]    get the number of elements of the n-th dimension of array a. (Note that MATLAB® uses 1 based indexing while Python uses 0 based indexing, See note INDEXING)
[ 1 2 3; 4 5 6 ]    array([[1.,2.,3.], [4.,5.,6.]]) 2x3 matrix literal
[ a b; c d ]    vstack([hstack([a,b]), hstack([c,d])]) or bmat('a b; c d').A    construct a matrix from blocks a,b,c, and d
a(end)  a[-1]   access last element in the 1xn matrix a
a(2,5)  a[1,4]  access element in second row, fifth column
a(2,:)  a[1] or a[1,:]  entire second row of a
a(1:5,:)    a[0:5] or a[:5] or a[0:5,:] the first five rows of a
a(end-4:end,:)  a[-5:]  the last five rows of a
a(1:3,5:9)  a[0:3][:,4:9]   rows one to three and columns five to nine of a. This gives read-only access.
a([2,4,5],[1,3])    a[ix_([1,3,4],[0,2])]   rows 2,4 and 5 and columns 1 and 3. This allows the matrix to be modified, and doesn’t require a regular slice.
a(3:2:21,:) a[ 2:21:2,:]    every other row of a, starting with the third and going to the twenty-first
a(1:2:end,:)    a[ ::2,:]   every other row of a, starting with the first
a(end:-1:1,:) or flipud(a)  a[ ::-1,:]  a with rows in reverse order
a([1:end 1],:)  a[r_[:len(a),0]]    a with copy of the first row appended to the end
a.' a.transpose() or a.T    transpose of a
a'  a.conj().transpose() or a.conj().T  conjugate transpose of a
a * b   a.dot(b)    matrix multiply
a .* b  a * b   element-wise multiply
a./b    a/b element-wise divide
a.^3    a**3    element-wise exponentiation
(a&gt;0.5) (a&gt;0.5) matrix whose i,jth element is (a_ij &gt; 0.5)
find(a&gt;0.5) nonzero(a&gt;0.5)  find the indices where (a &gt; 0.5)
a(:,find(v&gt;0.5))    a[:,nonzero(v&gt;0.5)[0]]  extract the columms of a where vector v &gt; 0.5
a(:,find(v&gt;0.5))    a[:,v.T&gt;0.5]    extract the columms of a where column vector v &gt; 0.5
a(a&lt;0.5)=0  a[a&lt;0.5]=0  a with elements less than 0.5 zeroed out
a .* (a&gt;0.5)    a * (a&gt;0.5) a with elements less than 0.5 zeroed out
a(:) = 3    a[:] = 3    set all values to the same scalar value
y=x y = x.copy()    numpy assigns by reference
y=x(2,:)    y = x[1,:].copy()   numpy slices are by reference
y=x(:)  y = x.flatten(1)    turn array into vector (note that this forces a copy)
1:10    arange(1.,11.) or r_[1.:11.] or r_[1:10:10j]    create an increasing vector (see note RANGES)
0:9 arange(10.) or r_[:10.] or r_[:9:10j]   create an increasing vector (see note RANGES)
[1:10]' arange(1.,11.)[:, newaxis]  create a column vector
zeros(3,4)  zeros((3,4))    3x4 rank-2 array full of 64-bit floating point zeros
zeros(3,4,5)    zeros((3,4,5))  3x4x5 rank-3 array full of 64-bit floating point zeros
ones(3,4)   ones((3,4)) 3x4 rank-2 array full of 64-bit floating point ones
eye(3)  eye(3)  3x3 identity matrix
diag(a) diag(a) vector of diagonal elements of a
diag(a,0)   diag(a,0)   square diagonal matrix whose nonzero values are the elements of a
rand(3,4)   random.rand(3,4)    random 3x4 matrix
linspace(1,3,4) linspace(1,3,4) 4 equally spaced samples between 1 and 3, inclusive
[x,y]=meshgrid(0:8,0:5) mgrid[0:9.,0:6.] or meshgrid(r_[0:9.],r_[0:6.]  two 2D arrays: one of x values, the other of y values
    ogrid[0:9.,0:6.] or ix_(r_[0:9.],r_[0:6.]   the best way to eval functions on a grid
[x,y]=meshgrid([1,2,4],[2,4,5]) meshgrid([1,2,4],[2,4,5])
    ix_([1,2,4],[2,4,5])    the best way to eval functions on a grid
repmat(a, m, n) tile(a, (m, n)) create m by n copies of a
[a b]   concatenate((a,b),1) or hstack((a,b)) or column_stack((a,b)) or c_[a,b] concatenate columns of a and b
[a; b]  concatenate((a,b)) or vstack((a,b)) or r_[a,b]  concatenate rows of a and b
max(max(a)) a.max() maximum element of a (with ndims(a)&lt;=2 for matlab)
max(a)  a.max(0)    maximum element of each column of matrix a
max(a,[],2) a.max(1)    maximum element of each row of matrix a
max(a,b)    maximum(a, b)   compares a and b element-wise, and returns the maximum value from each pair
norm(v) sqrt(dot(v,v)) or np.linalg.norm(v) L2 norm of vector v
a &amp; b   logical_and(a,b)    element-by-element AND operator (Numpy ufunc) See note LOGICOPS
a | b   logical_or(a,b) element-by-element OR operator (Numpy ufunc) See note LOGICOPS
bitand(a,b) a &amp; b   bitwise AND operator (Python native and Numpy ufunc)
bitor(a,b)  a | b   bitwise OR operator (Python native and Numpy ufunc)
inv(a)  linalg.inv(a)   inverse of square matrix a
pinv(a) linalg.pinv(a)  pseudo-inverse of matrix a
rank(a) linalg.matrix_rank(a)   rank of a matrix a
a\b linalg.solve(a,b) if a is square; linalg.lstsq(a,b) otherwise   solution of a x = b for x
b/a Solve a.T x.T = b.T instead solution of x a = b for x
[U,S,V]=svd(a)  U, S, Vh = linalg.svd(a), V = Vh.T  singular value decomposition of a
chol(a) linalg.cholesky(a).T    cholesky factorization of a matrix (chol(a) in matlab returns an upper triangular matrix, but linalg.cholesky(a) returns a lower triangular matrix)
[V,D]=eig(a)    D,V = linalg.eig(a) eigenvalues and eigenvectors of a
[V,D]=eig(a,b)  V,D = np.linalg.eig(a,b)    eigenvalues and eigenvectors of a,b
[V,D]=eigs(a,k)     find the k largest eigenvalues and eigenvectors of a
[Q,R,P]=qr(a,0) Q,R = scipy.linalg.qr(a)    QR decomposition
[L,U,P]=lu(a)   L,U = scipy.linalg.lu(a) or LU,P=scipy.linalg.lu_factor(a)  LU decomposition (note: P(Matlab) == transpose(P(numpy)) )
conjgrad    scipy.sparse.linalg.cg  Conjugate gradients solver
fft(a)  fft(a)  Fourier transform of a
ifft(a) ifft(a) inverse Fourier transform of a
sort(a) sort(a) or a.sort() sort the matrix
[b,I] = sortrows(a,i)   I = argsort(a[:,i]), b=a[I,:]   sort the rows of the matrix
regress(y,X)    linalg.lstsq(X,y)   multilinear regression
decimate(x, q)  scipy.signal.resample(x, len(x)/q)  downsample with low-pass filtering
unique(a)   unique(a)
squeeze(a)  a.squeeze()
Notes
Submatrix: Assignment to a submatrix can be done with lists of indexes using the ix_ command. E.g., for 2d array a, one might do: ind=[1,3]; a[np.ix_(ind,ind)]+=100.

HELP: There is no direct equivalent of MATLAB’s which command, but the commands help and source will usually list the filename where the function is located. Python also has an inspect module (do import inspect) which provides a getfile that often works.

INDEXING: MATLAB® uses one based indexing, so the initial element of a sequence has index 1. Python uses zero based indexing, so the initial element of a sequence has index 0. Confusion and flamewars arise because each has advantages and disadvantages. One based indexing is consistent with common human language usage, where the “first” element of a sequence has index 1. Zero based indexing simplifies indexing. See also a text by prof.dr. Edsger W. Dijkstra.

RANGES: In MATLAB®, 0:5 can be used as both a range literal and a ‘slice’ index (inside parentheses); however, in Python, constructs like 0:5 can only be used as a slice index (inside square brackets). Thus the somewhat quirky r_ object was created to allow numpy to have a similarly terse range construction mechanism. Note that r_ is not called like a function or a constructor, but rather indexed using square brackets, which allows the use of Python’s slice syntax in the arguments.

LOGICOPS: &amp; or | in Numpy is bitwise AND/OR, while in Matlab &amp; and | are logical AND/OR. The difference should be clear to anyone with significant programming experience. The two can appear to work the same, but there are important differences. If you would have used Matlab’s &amp; or | operators, you should use the Numpy ufuncs logical_and/logical_or. The notable differences between Matlab’s and Numpy’s &amp; and | operators are:

Non-logical {0,1} inputs: Numpy’s output is the bitwise AND of the inputs. Matlab treats any non-zero value as 1 and returns the logical AND. For example (3 &amp; 4) in Numpy is 0, while in Matlab both 3 and 4 are considered logical true and (3 &amp; 4) returns 1.
Precedence: Numpy’s &amp; operator is higher precedence than logical operators like &lt; and &gt;; Matlab’s is the reverse.
If you know you have boolean arguments, you can get away with using Numpy’s bitwise operators, but be careful with parentheses, like this: z = (x &gt; 1) &amp; (x &lt; 2). The absence of Numpy operator forms of logical_and and logical_or is an unfortunate consequence of Python’s design.

RESHAPE and LINEAR INDEXING: Matlab always allows multi-dimensional arrays to be accessed using scalar or linear indices, Numpy does not. Linear indices are common in Matlab programs, e.g. find() on a matrix returns them, whereas Numpy’s find behaves differently. When converting Matlab code it might be necessary to first reshape a matrix to a linear sequence, perform some indexing operations and then reshape back. As reshape (usually) produces views onto the same storage, it should be possible to do this fairly efficiently. Note that the scan order used by reshape in Numpy defaults to the ‘C’ order, whereas Matlab uses the Fortran order. If you are simply converting to a linear sequence and back this doesn’t matter. But if you are converting reshapes from Matlab code which relies on the scan order, then this Matlab code: z = reshape(x,3,4); should become z = x.reshape(3,4,order=’F’).copy() in Numpy.

Customizing Your Environment
In MATLAB® the main tool available to you for customizing the environment is to modify the search path with the locations of your favorite functions. You can put such customizations into a startup script that MATLAB will run on startup.

NumPy, or rather Python, has similar facilities.

To modify your Python search path to include the locations of your own modules, define the PYTHONPATH environment variable.
To have a particular script file executed when the interactive Python interpreter is started, define the PYTHONSTARTUP environment variable to contain the name of your startup script.
Unlike MATLAB®, where anything on your path can be called immediately, with Python you need to first do an ‘import’ statement to make functions in a particular file accessible.

For example you might make a startup script that looks like this (Note: this is just an example, not a statement of “best practices”):

# Make all numpy available via shorter 'num' prefix
import numpy as num
# Make all matlib functions accessible at the top level via M.func()
import numpy.matlib as M
# Make some matlib functions accessible directly at the top level via, e.g. rand(3,3)
from numpy.matlib import rand,zeros,ones,empty,eye
# Define a Hermitian function
def hermitian(A, **kwargs):
    return num.transpose(A,**kwargs).conj()
# Make some shorcuts for transpose,hermitian:
#    num.transpose(A) - -&gt; T(A)
#    hermitian(A) - -&gt; H(A)
T = num.transpose
H = hermitian
Links
See http://mathesaurus.sf.net/ for another MATLAB®/NumPy cross-reference.

An extensive list of tools for scientific work with python can be found in the topical software page.

MATLAB® and SimuLink® are registered trademarks of The MathWorks. --&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;</description><category>mathjax</category><category>MATLAB</category><category>NumPy</category><category>python</category><guid>https://numython.github.io/posts/numpy-para-usuarios-de-matlab/</guid><pubDate>Tue, 18 Oct 2016 15:58:03 GMT</pubDate></item><item><title>SymPy, calculando la ecuación de un plano dados tres puntos</title><link>https://numython.github.io/posts/2016/03/sympy-es-una-de-esas-librerias-que-lo/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;SymPy es una de esas librerías que lo mismo sirven para hacer grandes cosas, que para &lt;em&gt;desempolvar&lt;/em&gt; recuerdos y aplicarlos en cuestiones más orientadas a la etapa académica. Y es que las cuestiones de algebra simbólica suelen ser muy divertidas y lo suficientemente interesantes para mantener a un individuo ocupado.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Bueno, sin más preámbulos, en este post vamos a ver cómo utilizar SymPy para calcular la ecuación de un plano dados tres puntos contenidos en este.&lt;/div&gt;&lt;br&gt;Primero un poco de geometría elemental. Sean los tres puntos contenidos en el plano los siguientes:&lt;br&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt; = (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;1&lt;/sub&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt; = (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;2&lt;/sub&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;P&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt; = (&lt;em&gt;x&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;, &lt;em&gt;y&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;, &lt;em&gt;z&lt;/em&gt;&lt;sub&gt;3&lt;/sub&gt;)&lt;/span&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Luego, la ecuación implícita del plano podemos obtenerla resolviendo la ecuación dada por el determinante siguiente:&lt;/div&gt;&lt;br&gt;&lt;span class="math display"&gt;$$ \left|\begin{matrix} x - x_1 &amp;amp; y - y_1 &amp;amp; z - z_1 \\ x_2 - x_1 &amp;amp; y_2 - y_2 &amp;amp; z_2 - z_1 \\ x_3 - x_1 &amp;amp; y_3 - y_1 &amp;amp; z_3 - z_1 \\ \end{matrix}\right| = 0 $$&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;La solución tradicional creo que, llegados a este punto, todos podemos obtenerla sin ningún tipo de sobresalto. Ahora, la idea es implementar una solución utilizando SymPy.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;SymPy dispone de una clase &lt;code style="white-space: pre;"&gt;Matrix&lt;/code&gt;, que recibe como argumentos de entrada una lista de valores numéricos o bien de cualquier variable simbólica que haya sido definida previamente. Está claro que en este caso los valores de las coordenadas de los puntos son conocidos, pero las variables \(x, y, z\) serán variables de tipo simbólico. Para calcular el determinante de una matriz podemos utilizar la función &lt;code style="white-space: pre;"&gt;det&lt;/code&gt;, que recibe como argumento de entrada un objeto de la clase Matrix. Una vez resuelto el determinante tendremos una ecuación de la forma:&lt;/div&gt;&lt;br&gt;&lt;span class="math display"&gt;&lt;em&gt;A&lt;/em&gt;&lt;em&gt;x&lt;/em&gt; + &lt;em&gt;B&lt;/em&gt;&lt;em&gt;y&lt;/em&gt; + &lt;em&gt;C&lt;/em&gt;&lt;em&gt;z&lt;/em&gt; − &lt;em&gt;k&lt;/em&gt; = 0&lt;/span&gt;&lt;br&gt;&lt;br&gt;Veamos el código implementado en SymPy:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Matrix, det&lt;br&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x,y,z&lt;br&gt;&lt;br&gt;P1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;3&lt;/span&gt;)&lt;br&gt;P2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;br&gt;P3 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;)&lt;br&gt;&lt;br&gt;M &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; Matrix([[x&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]     , y&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]     , z&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]    ,&lt;br&gt;            [P2[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]],&lt;br&gt;            [P3[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]])&lt;br&gt;&lt;br&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st" style="color: #4070a0;"&gt;u"Ecuación implícita: &lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt; = 0"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;det(M))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Lo cual nos devolverá en consola la ecuación implícita del plano:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;Ecuación implícita: &lt;span class="dv" style="color: #40a070;"&gt;13&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; y &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;z &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;9&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Ahora bien, si requerimos la ecuación anterior expresada de forma explícita como una función bivariable del tipo \(z=f(x,y)\), entonces, debemos utilizar la función &lt;code style="white-space: pre;"&gt;solve&lt;/code&gt; y resolver la ecuación planteada respecto a \(z\), por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Matrix, solve, det&lt;br&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x,y,z&lt;br&gt;&lt;br&gt;P1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;3&lt;/span&gt;)&lt;br&gt;P2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;br&gt;P3 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; (&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;,&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;)&lt;br&gt;&lt;br&gt;M &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; Matrix([[x&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]     , y&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]     , z&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]    ,&lt;br&gt;            [P2[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P2[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]],&lt;br&gt;            [P3[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;] , P3[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;P1[&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;]]])&lt;br&gt;&lt;br&gt;sol &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; solve(det(M), z)&lt;br&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st" style="color: #4070a0;"&gt;u"Ecuación implícita: &lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt; = 0"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;det(M))&lt;br&gt;&lt;span class="bu"&gt;print&lt;/span&gt;(&lt;span class="st" style="color: #4070a0;"&gt;u"Ecuación explícita: z=&lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;(sol[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;]))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Resultando:&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;Ecuación implícita: &lt;span class="dv" style="color: #40a070;"&gt;13&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; y &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;z &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;9&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;&lt;br&gt;Ecuación explícita: z&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;13&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; y&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;9&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;/&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Incluso podemos graficar nuestro plano utilizando la función &lt;code style="white-space: pre;"&gt;plot3d&lt;/code&gt; del módulo &lt;code style="white-space: pre;"&gt;plotting&lt;/code&gt;:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from sympy import latex&lt;/span&gt;&lt;/code&gt;&lt;br&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;from&lt;/span&gt; sympy.plotting &lt;span class="im"&gt;import&lt;/span&gt; plot3d&lt;br&gt;&lt;br&gt;plot3d(sol[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;], (x,&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;), (y,&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;), title&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"$z = &lt;/span&gt;&lt;span class="sc" style="color: #4070a0;"&gt;%s&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;$"&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;%&lt;/span&gt;(latex(sol[&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;])))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-q9746nrlTnw/VtiKBse1HBI/AAAAAAAAByY/npjCaWNgTRA/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="300" src="https://1.bp.blogspot.com/-q9746nrlTnw/VtiKBse1HBI/AAAAAAAAByY/npjCaWNgTRA/s400/img_01.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>CAS</category><category>mathjax</category><category>SymPy</category><guid>https://numython.github.io/posts/2016/03/sympy-es-una-de-esas-librerias-que-lo/</guid><pubDate>Fri, 04 Mar 2016 01:02:00 GMT</pubDate></item><item><title>Funciones definidas a trozos (piecewise) con NumPy</title><link>https://numython.github.io/posts/2016/02/funciones-definidas-trozos-piecewise/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Una función definida a trozos es una función real \(f\) de una variable real \(x\), cuya definición está dada por varios conjuntos disjuntos de su dominio. &lt;sup&gt;[1]&lt;/sup&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;El ejemplo clásico de una función definida por secciones es la función valor absoluto \(abs(x)\), habitualmente definida por:&lt;/div&gt;&lt;br&gt;&lt;span class="math display"&gt;$$ f(x)= |x| = \left\{ \begin{matrix} -x &amp;amp; si \,\, x &amp;lt; 0 \\ x &amp;amp; si \,\, x \geq 0 \\ \end{matrix}\right. $$&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;De manera ordinaria, en NumPy, para definir una función en un intervalo tendríamos que crear un vector de \(n\) cantidad de puntos en ese intervalo, y posteriormente crear la expresión que define la función, por ejemplo, definiendo a \(f(x)=x\,\,cos(x)\)&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;np.linspace(&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; y&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;x&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;np.cos(x)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Ahora, dada la naturaleza de las funciones por tramos, estás no pueden definirse como en las líneas anteriores, puesto que la expresión que las define depende del intervalo. Una opción para crear una función a trozos sería definiendo un intervalo para cada expresión y posteriormente concatenar todo en un mismo arreglo, tanto para los intervalos como las expresiones.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Por ejemplo, definiendo la función valor absoluto en el intervalo \((-10,10)\):&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;x1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;)&lt;br&gt;x2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;)&lt;br&gt;y1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;x1&lt;br&gt;y2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; x2&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.concatenate((x1,x2))&lt;br&gt;y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.concatenate((y1,y2))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Si, lo anterior puede parecer un poco &lt;em&gt;tedioso&lt;/em&gt;, así que NumPy también dispone de una función que nos ahorra el estar escribiendo mucho código: &lt;code style="white-space: pre;"&gt;piecewise&lt;/code&gt;, la cual nos permite crear un arreglo a partir de otro (intervalo), seccionando este acorde a las expresiones/funciones pasadas como argumentos y a las condiciones lógicas para definir los subintervalos. En términos simples la sintaxis de &lt;code style="white-space: pre;"&gt;piecewise&lt;/code&gt; es:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;np.piecewise(x, logls, funls)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Donde &lt;code style="white-space: pre;"&gt;x&lt;/code&gt; es un arreglo que define la variable independiente, &lt;code style="white-space: pre;"&gt;logls&lt;/code&gt; una lista de condiciones lógicas para seccionar y definir los subintervalos, y &lt;code style="white-space: pre;"&gt;funls&lt;/code&gt; una lista de funciones o constantes que definen el valor de la función para el subintervalo correspondiente.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Siguiendo con nuestro ejemplo de la función valor absoluto, haríamos algo como lo siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;)&lt;br&gt;y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.piecewise(x, [x&lt;span class="op" style="color: #666666;"&gt;&amp;lt;&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;, x&lt;span class="op" style="color: #666666;"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;], [&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;x, &lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: x])&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Desde luego también se pueden usar funciones ordinarias en lugar de lambdas.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Para hacer esto un poco más &lt;em&gt;ilustrativo&lt;/em&gt; vamos a utilizar Matplotlib para trazar la gráfica correspondiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt &lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;)&lt;br&gt;y &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.piecewise(x, [x&lt;span class="op" style="color: #666666;"&gt;&amp;lt;&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;, x&lt;span class="op" style="color: #666666;"&gt;&amp;gt;=&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;], [&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt;x, &lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;lambda&lt;/span&gt; x: x])&lt;br&gt;&lt;br&gt;plt.plot(x, y)&lt;br&gt;&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Funciones%20definidas%20a%20trozos%20(piecewise)%20con%20Numpy/img/img_01.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://2.bp.blogspot.com/-Wrz9la4Vedg/VtS0t9Vt9AI/AAAAAAAAByE/abcTdoAzXEU/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="300" src="https://2.bp.blogspot.com/-Wrz9la4Vedg/VtS0t9Vt9AI/AAAAAAAAByE/abcTdoAzXEU/s400/img_01.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;strong&gt;&lt;br&gt;&lt;/strong&gt;&lt;strong&gt;Referencias:&lt;/strong&gt;&lt;br&gt;[1]. &lt;a href="https://es.wikipedia.org/wiki/Funci%C3%B3n_definida_a_trozos"&gt;https://es.wikipedia.org/wiki/Funci%C3%B3n_definida_a_trozos&lt;/a&gt;</description><category>mathjax</category><category>NumPy</category><guid>https://numython.github.io/posts/2016/02/funciones-definidas-trozos-piecewise/</guid><pubDate>Tue, 01 Mar 2016 03:15:00 GMT</pubDate></item><item><title>Utilizando estilos en Matplotlib</title><link>https://numython.github.io/posts/2016/02/utilizando-estilos-en-matplotlib/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Por defecto Matplotlib tiene un estilo definido, un aspecto muy característico y facilmente reconocible. Pero también permite personalizar los estilos de gráficas de una forma muy sencilla, utilizando hojas de estilos predefinidas y que vienen incluidas con Matplotlib, aunque también existe la posibilidad de crearlas, pero de eso hablaremos luego.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Para ver los estilos que tenemos disponibles podemos importar pyplot y posteriormente teclear lo siguiente:&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="bu"&gt;print&lt;/span&gt; plt.style.available&lt;br&gt;[&lt;span class="st" style="color: #4070a0;"&gt;u'labdls-dark'&lt;/span&gt;,&lt;span class="st" style="color: #4070a0;"&gt;u'grayscale'&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;u'bmh'&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;u'dark_background'&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;u'ggplot'&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;u'fivethirtyeight'&lt;/span&gt;]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Como puede observar lo anterior nos devuelve una lista con los estilos disponibles. El primer elemento de la lista es un estilo personalizada, así que seguro no estará en los estilos que le devuelva su consola.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Para utilizar un determinado estilo debe anteponer al código Matplotlib (justo después de las líneas de importación de módulos) lo siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;plt.style.use(estilo)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Donde estilo es un string con el nombre del estilo a utilizar, por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;plt.style.use(&lt;span class="st" style="color: #4070a0;"&gt;'ggplot'&lt;/span&gt;)&lt;br&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.linspace(&lt;span class="dv" style="color: #40a070;"&gt;0&lt;/span&gt;, &lt;span class="dv" style="color: #40a070;"&gt;4&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;np.pi, &lt;span class="dv" style="color: #40a070;"&gt;100&lt;/span&gt;)&lt;br&gt;y1 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;np.cos(x)&lt;br&gt;y2 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;np.sin(x)&lt;br&gt;y3 &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.sin(x)&lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt;np.cos(x)&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;br&gt;ax.plot(x, y1, label&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"$x\,cos(x)$"&lt;/span&gt;)&lt;br&gt;ax.plot(x, y2, label&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"$x\,sin(x)$"&lt;/span&gt;)&lt;br&gt;ax.plot(x, y3, label&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="st" style="color: #4070a0;"&gt;"$sin(x)+cos(x)$"&lt;/span&gt;)&lt;br&gt;ax.legend()&lt;br&gt;ax.set_xlabel(&lt;span class="st" style="color: #4070a0;"&gt;"Tiempo (s)"&lt;/span&gt;)&lt;br&gt;ax.set_ylabel(&lt;span class="st" style="color: #4070a0;"&gt;"Amplitud (mm)"&lt;/span&gt;)&lt;br&gt;&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-vDcGLp7f9Ek/Vs30SoF2w0I/AAAAAAAABxw/rzvZ3vWifak/s1600/img_02.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="300" src="https://1.bp.blogspot.com/-vDcGLp7f9Ek/Vs30SoF2w0I/AAAAAAAABxw/rzvZ3vWifak/s400/img_02.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Ahora nuestra gráfica luce un tanto distinta a lo que normalmente estamos acostumbrados en Matplotlib. Para dar un vistazo general a cómo se ven los demás estilos puede implementar el siguiente script:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;br&gt;X &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.random.random((&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;3&lt;/span&gt;))&lt;br&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure(figsize&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;(&lt;span class="dv" style="color: #40a070;"&gt;12&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;8&lt;/span&gt;))&lt;br&gt;styles &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.style.available&lt;br&gt;&lt;br&gt;&lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;for&lt;/span&gt; k,style &lt;span class="op" style="color: #666666;"&gt;in&lt;/span&gt; &lt;span class="bu"&gt;enumerate&lt;/span&gt;(styles):&lt;br&gt;    plt.style.use(style)&lt;br&gt;    cax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;3&lt;/span&gt;,k)&lt;br&gt;    cax.set_title(style)&lt;br&gt;    cax.plot(X)&lt;br&gt;&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://3.bp.blogspot.com/-TO-t98vwWHg/Vs30RaVRT5I/AAAAAAAABxs/kfO0If0Xo4g/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="266" src="https://3.bp.blogspot.com/-TO-t98vwWHg/Vs30RaVRT5I/AAAAAAAABxs/kfO0If0Xo4g/s400/img_01.png" width="400"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Muy interesantes, pero claro, siempre hará falta un poco de personalización que añada ese toque final. Por ello en entradas posteriores hablaremos de cómo crear una hoja de estilos Matplotlib.&lt;/div&gt;</description><category>Matplotlib. mathjax</category><guid>https://numython.github.io/posts/2016/02/utilizando-estilos-en-matplotlib/</guid><pubDate>Thu, 25 Feb 2016 00:20:00 GMT</pubDate></item><item><title>Graficar en Python con Matplotlib y NumPy</title><link>https://numython.github.io/posts/2016/02/graficar-en-python-con-matplotlib-y/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Trazar gráficas en Python es muy sencillo, para ello necesita tener instaladas las librerías matplotlib y numpy, las cuales pueden encontrarse y descargar de la red sin mayores obstáculos. Debe asegurarse que la versión de las librerías sea compatible con la versión de Python.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Si alguna vez ha utilizado MATLAB para estos mismos fines, las instrucciones le parecerán demasiado familiar.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Enseguida os adjunto un código sencillo y el resultado que produce:&lt;/div&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;import matplotlib.pyplot as plt&lt;br&gt;import numpy as np&lt;br&gt;&lt;br&gt;x = np.arange(0,10,0.1)&lt;br&gt;y = x*np.cos(x)&lt;br&gt;&lt;br&gt;plt.plot(x,y)&lt;br&gt;plt.xlabel('x')&lt;br&gt;plt.ylabel('y')&lt;br&gt;plt.title('Lab DLS')&lt;br&gt;plt.show()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-F1Qzh-W-7Gw/UxvtzNBs2VI/AAAAAAAABEk/wYX758jaymM/s1600/graph1.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="271" src="https://2.bp.blogspot.com/-F1Qzh-W-7Gw/UxvtzNBs2VI/AAAAAAAABEk/wYX758jaymM/s1600/graph1.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Las primeras dos líneas sirven para importar las librerías que se utilizarán. Recuerde que en Python pueden utilizarse seudónimos al cargar una librería (en este caso plt para matplotlib.pyplot y np para numpy).&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;En la línea se 4 se define el vector de la variable independiente utilizando la instrucción arange de la librería numpy, el cual crea un vector especificando el valor inicial, el valor final y el incremento como argumentos. La linea 5 crea simplemente un vector dependiente del primero.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;La instrucción plot gráfica los vectores creados con anterioridad, teniendo como primer argumento el vector de la variable independiente. Con xlabel, ylabel y title se muestran las etiquetas correspondientes a los ejes horizontal, vertical y el título en la parte superior respectivamente. Finalmente, la instrucción show() sirve para mostrar la ventana gráfica creada y poder visualizar lo que se ha trazado.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;b&gt;&lt;span style="font-size: large;"&gt;Modificando la presentación...&lt;/span&gt;&lt;/b&gt;&lt;/div&gt;&lt;br&gt;&lt;i&gt;Grosor de línea&lt;/i&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Para modificar el grosor de línea basta con incluir como argumento adicional en plot la propiedad linewidth, tal como se muestra enseguida:&lt;/div&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.plot(x,y,linewidth=4)&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;i&gt;Color de línea&lt;/i&gt;&lt;br&gt;&lt;br&gt;El siguiente ejemplo configura el color de la línea, en este caso rojo.&lt;br&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.plot(x,y,color='r')&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;También puede especificar el color utilizando una tupla de 3 elementos (R,G,B) en el intervalo [0 1], por ejemplo:&lt;/div&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.plot(x,y,color=(0.8,0.9,0))&lt;/pre&gt;&lt;br&gt;&lt;i&gt;Agregando rejilla&lt;/i&gt;&lt;br&gt;&lt;br&gt;Para agregar una rejilla debe incluirse la instrucción grid() como se muestra:&lt;br&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;plt.grid()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;&lt;span style="font-size: large;"&gt;Mostrar más de una gráfica&lt;/span&gt;&lt;/b&gt;&lt;br&gt;&lt;br&gt;Para mostrar más de una gráfica en la misma ventana, utilice hold(True) después de haber creado la primer gráfica o bien antes de ella, tal como se muestra en el código siguiente:&lt;br&gt;&lt;br&gt;&lt;pre class="brush: python"&gt;import matplotlib.pyplot as plt&lt;br&gt;import numpy as np&lt;br&gt;&lt;br&gt;x = np.arange(0,10,0.2)&lt;br&gt;y1 = np.cos(x)&lt;br&gt;y2 = np.sin(x)&lt;br&gt;&lt;br&gt;plt.plot(x,y1,'o',linewidth=3,color=(0.2,0.1,0.4))&lt;br&gt;plt.hold(True)&lt;br&gt;plt.plot(x,y2,'-',linewidth=2,color='g')&lt;br&gt;plt.grid()&lt;br&gt;plt.axis('equal')&lt;br&gt;plt.xlabel('x')&lt;br&gt;plt.ylabel('y')&lt;br&gt;plt.title('Lab DLS')&lt;br&gt;plt.show()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-zLEWNeou8Ck/UxwGMYIi3wI/AAAAAAAABE0/m1tXOSZnuOM/s1600/graph2.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="270" src="https://3.bp.blogspot.com/-zLEWNeou8Ck/UxwGMYIi3wI/AAAAAAAABE0/m1tXOSZnuOM/s1600/graph2.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;</description><category>mathjax</category><category>Matplotlib</category><category>NumPy</category><guid>https://numython.github.io/posts/2016/02/graficar-en-python-con-matplotlib-y/</guid><pubDate>Wed, 24 Feb 2016 22:52:00 GMT</pubDate></item><item><title>Gráficas de barras en Matplotlib</title><link>https://numython.github.io/posts/2016/02/graficas-de-barras-en-matplotlib/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;p&gt;Esta entrada tiene como objetivo mostrar el uso de Matplotlib/Python como herramienta para generar una gráfica de barras.&lt;br&gt;&lt;br&gt;Bien, para nuestro ejemplo vamos a suponer que se tienen como datos las calificaciones de 5 alumnos guardadas en una lista, y que tenemos también otra lista con los nombres correspondientes a cada uno, evidentemente en el mismo orden. Os adjunto el script y enseguida la explicación de cada linea:&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;pre class="brush: python"&gt;#-*- coding: utf-8 -*-&lt;br&gt;import matplotlib.pyplot as plt&lt;br&gt;&lt;br&gt;fig = plt.figure(u'Gráfica de barras') # Figure&lt;br&gt;ax = fig.add_subplot(111) # Axes&lt;br&gt;&lt;br&gt;nombres = ['Juan','Ana','Pablo','Ximena','Jorge']&lt;br&gt;datos = [90,88,78,94,93]&lt;br&gt;xx = range(len(datos))&lt;br&gt;&lt;br&gt;ax.bar(xx, datos, width=0.8, align='center')&lt;br&gt;ax.set_xticks(xx)&lt;br&gt;ax.set_xticklabels(nombres)&lt;br&gt;&lt;br&gt;plt.show()&lt;br&gt;&lt;/pre&gt;&lt;br&gt;&lt;br&gt;La primera linea sirve para especificar la codificación utilizada en el fichero y con ello evitar todo tipo de "sorpresas" debido a la peculiaridad de nuestro idioma, de modo que es necesaria. La segunda linea importa el módulo pyplot de la librería Matplotlib utilizando el alias plt.&lt;br&gt;&lt;br&gt;Luego, creamos una nueva ventana mediante el uso de figure, y añadimos enseguida un axes mediante la instrucción add_subplot(111), donde el 111 indica que solamente se tendrá un eje coordenado dentro de la ventana.&lt;br&gt;&lt;br&gt;Posteriormente se definen las listas que servirán como entrada para trazar la gráfica de barras. En la lista nombre se guarda un arreglo de strings con los nombres de cada alumno, en datos se guardan las calificaciones correspondientes y xx es una lista de enteros desde 0 a N-1, donde N es el número de elementos que contiene la lista datos, xx servirá para especificar los puntos ubicados en el eje horizontal en los cuales se trazarán las barras.&lt;br&gt;&lt;br&gt;Una vez se han creado las listas, se procede a trazar la gráfica de barras mediante la función bar, cuyos parámetros de entrada son la lista xx y la lista de datos y/o calificaciones. Además de lo anterior, pueden utilizarse keywords arguments como width o align que sirven para especificar el ancho y la alineación de las barras trazadas. Luego, la función set_xticks define las marcas utilizadas para etiquetar al eje horizontal, y set_xticklabels permite colocar una lista de strings como etiquetas personalizadas, que en este caso corresponde a la lista de nombres.&lt;br&gt;&lt;br&gt;Finalmente se utiliza la función show para mostrar todo lo que se ha trazado. Se adjunta la salida gráfica del script en cuestión.&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-x2jFDeLSido/VKTKUfDsciI/AAAAAAAABY8/K_dbQk01FFg/s1600/Captura.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="267" src="https://4.bp.blogspot.com/-x2jFDeLSido/VKTKUfDsciI/AAAAAAAABY8/K_dbQk01FFg/s1600/Captura.PNG" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>Gráficas</category><category>mathjax</category><category>Matplotlib</category><guid>https://numython.github.io/posts/2016/02/graficas-de-barras-en-matplotlib/</guid><pubDate>Wed, 24 Feb 2016 22:47:00 GMT</pubDate></item><item><title>Sympy live, una "consola" de Python online.</title><link>https://numython.github.io/posts/2016/02/sympy-live-una-consola-de-python-online/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Sympy live (&lt;a href="http://live.sympy.org/"&gt;http://live.sympy.org/&lt;/a&gt;) es una aplicación web que permite ejecutar código Python en línea, y claro, con la ventaja que permite utilizar la librería Sympy para realizar cálculos de computación simbólica.&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-5Blr-tcS2pw/VopXqOBMfRI/AAAAAAAABok/9qElSzxoku0/s1600/img_01.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="494" src="https://3.bp.blogspot.com/-5Blr-tcS2pw/VopXqOBMfRI/AAAAAAAABok/9qElSzxoku0/s640/img_01.PNG" width="640"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;A continuación se muestran algunas operaciones realizadas utilizando esta aplicación.&lt;br&gt;&lt;br&gt;&lt;b&gt;Manipulación algebraica&lt;/b&gt;&lt;br&gt;&lt;br&gt;Expandiendo la expresión $(x+1) ^2$ y factorizando $x^2+6x-16$:&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-BRQbsDTb82E/Vopbbk92tmI/AAAAAAAABo0/xjhaKkEQzmA/s1600/img_02.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://1.bp.blogspot.com/-BRQbsDTb82E/Vopbbk92tmI/AAAAAAAABo0/xjhaKkEQzmA/s1600/img_02.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b&gt;Resolviendo ecuaciones e inecuaciones&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://2.bp.blogspot.com/-Yh_YU2wHOLc/VopfzJchnbI/AAAAAAAABpE/vA9ZagdGHb0/s1600/img_03.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://2.bp.blogspot.com/-Yh_YU2wHOLc/VopfzJchnbI/AAAAAAAABpE/vA9ZagdGHb0/s1600/img_03.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Sistemas de ecuaciones lineales&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-NYQtAAGXTC4/Vopf3AOHhVI/AAAAAAAABpM/F09PC_J7ZJg/s1600/img_04.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://4.bp.blogspot.com/-NYQtAAGXTC4/Vopf3AOHhVI/AAAAAAAABpM/F09PC_J7ZJg/s1600/img_04.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Derivadas&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://1.bp.blogspot.com/-wrN943SLJXQ/VophtmPZ88I/AAAAAAAABpY/fPMl18OxRFk/s1600/img_05.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://1.bp.blogspot.com/-wrN943SLJXQ/VophtmPZ88I/AAAAAAAABpY/fPMl18OxRFk/s1600/img_05.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;b&gt;&lt;br&gt;&lt;/b&gt;&lt;b&gt;Integrales&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-BpmobKGJMD8/Vophu2QYH2I/AAAAAAAABpg/anefRm29pA0/s1600/img_06.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://3.bp.blogspot.com/-BpmobKGJMD8/Vophu2QYH2I/AAAAAAAABpg/anefRm29pA0/s1600/img_06.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Integrales múltiples&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://4.bp.blogspot.com/-C67lhgBWVrs/VopjGJyLH6I/AAAAAAAABps/e2F3Vx-_6iE/s1600/img_07.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://4.bp.blogspot.com/-C67lhgBWVrs/VopjGJyLH6I/AAAAAAAABps/e2F3Vx-_6iE/s1600/img_07.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;b&gt;Ecuaciones diferenciales&lt;/b&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="http://3.bp.blogspot.com/-fxu-0EXJlnQ/VopnQA-AqfI/AAAAAAAABqE/h-I3xc2BD6c/s1600/img_08.PNG" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" src="https://3.bp.blogspot.com/-fxu-0EXJlnQ/VopnQA-AqfI/AAAAAAAABqE/h-I3xc2BD6c/s1600/img_08.PNG"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;</description><category>CAS</category><category>mathjax</category><category>SymPy</category><guid>https://numython.github.io/posts/2016/02/sympy-live-una-consola-de-python-online/</guid><pubDate>Wed, 24 Feb 2016 22:46:00 GMT</pubDate></item><item><title>Borrar líneas en Matplotlib de manera interactiva</title><link>https://numython.github.io/posts/2016/02/borrar-lineas-en-matplotlib-de-manera/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;div style="text-align: justify;"&gt;Matplotlib es una librería normalmente utilizada para trazar gráficas que habrán de exportarse como un archivo "estático" e incluirse en algún tipo de documento posteriormente. Pero además, Matplotlib también tiene algunas características que permiten que el usuario pueda interactuar, tales como los widgets o los eventos definidos por el usuario. Y esta última característica vamos a aprovechar en este post para ver cómo poder borrar líneas de una gráfica Matplotlib una vez que esta ha sido creada, esto mediante la selección a través del mouse.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Los eventos en Matplotlib se "conectan" utilizando el método &lt;code style="white-space: pre;"&gt;mpl_connect&lt;/code&gt; de la clase &lt;code style="white-space: pre;"&gt;FigureCanvas&lt;/code&gt;, mediante la sintaxis siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;hevt &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;'tipo_evento'&lt;/span&gt;, fun)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Donde &lt;code style="white-space: pre;"&gt;hevt&lt;/code&gt; es una variable en la cual se guarda la referencia al evento y que puede ser utilizada para desconectarlo cuando no lo necesitemos más, &lt;code style="white-space: pre;"&gt;fig&lt;/code&gt; es una instancia de la clase &lt;code style="white-space: pre;"&gt;Figure&lt;/code&gt;, &lt;code style="white-space: pre;"&gt;tipo_evento&lt;/code&gt; es uno de los eventos que pueden ser conectados en Matplotlib, cuya lista puede ver &lt;a href="http://matplotlib.org/users/event_handling.html#event-connections"&gt;aquí&lt;/a&gt;, y &lt;code style="white-space: pre;"&gt;fun&lt;/code&gt; es una función en la cual deberá programarse la respuesta de nuestro programa cuando se lance el evento.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;Por ahora nos interesa el tipo de evento &lt;code style="white-space: pre;"&gt;pick_event&lt;/code&gt;, el cual se "lanza" cuando un objeto en el canvas actual es seleccionado. Así, para conectar nuestro evento haremos algo como lo siguiente:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;pick &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;"pick_event"&lt;/span&gt;, OnSelect)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Ahora vamos a por todo el código y enseguida explicamos para qué cada cosa:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; wx&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;def&lt;/span&gt; OnSelect(event):&lt;br&gt;    app &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.App()&lt;br&gt;    dlg &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.MessageDialog(&lt;span class="va" style="color: #19177c;"&gt;None&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;"Desea borrar"&lt;/span&gt;,&lt;br&gt;    &lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;'Matplotlib Demo'&lt;/span&gt;, wx.YES_NO&lt;span class="op" style="color: #666666;"&gt;|&lt;/span&gt;wx.ICON_QUESTION)&lt;br&gt;    &lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;if&lt;/span&gt; dlg.ShowModal() &lt;span class="op" style="color: #666666;"&gt;==&lt;/span&gt; wx.ID_YES:&lt;br&gt;        event.artist.remove()&lt;br&gt;    dlg.Destroy()&lt;br&gt;    app.MainLoop()&lt;br&gt;    fig.canvas.draw()&lt;br&gt;&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Definir datos a plotear&lt;/span&gt;&lt;br&gt;X &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.random.random((&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;))&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Crear figure y axes&lt;/span&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Graficar datos&lt;/span&gt;&lt;br&gt;ax.plot(X, picker&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="va" style="color: #19177c;"&gt;True&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Conectar evento "pick_event"&lt;/span&gt;&lt;br&gt;pick &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;"pick_event"&lt;/span&gt;, OnSelect)&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://4.bp.blogspot.com/-3IUBZXZPaX0/Vs12S30wNaI/AAAAAAAABxU/cD9orfSktFo/s1600/img_01.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="268" src="https://4.bp.blogspot.com/-3IUBZXZPaX0/Vs12S30wNaI/AAAAAAAABxU/cD9orfSktFo/s320/img_01.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Primero, importamos, claro, los módulos a utilizar. Lo de wxPython es &lt;em&gt;opcional&lt;/em&gt;, sólo nos servirá para confirmar si realmente queremos borrar cierta línea y puede sustituirse con cualquier otra librería gráfica, Tkinter por ejemplo. Luego, definimos unos datos aleatorios, creamos nuestra &lt;code style="white-space: pre;"&gt;Figure&lt;/code&gt; y nuestro &lt;code style="white-space: pre;"&gt;Axes&lt;/code&gt; de la manera en que se debe, y posteriormente &lt;em&gt;ploteamos&lt;/em&gt; los datos utilizando &lt;code style="white-space: pre;"&gt;plot&lt;/code&gt;, pero adicionando el&lt;em&gt;keyword argument&lt;/em&gt; &lt;code style="white-space: pre;"&gt;picker=True&lt;/code&gt; para decirle a Matplotlib que para nuestro objeto gráfico resultante requerimos que esté disponible para ser seleccionado mediante el mouse. Y finalmente conectamos el evento de tipo &lt;code style="white-space: pre;"&gt;"pick_event"&lt;/code&gt; al canvas correspondiente, pasando a la función &lt;code style="white-space: pre;"&gt;OnSelect&lt;/code&gt; como la encargada de &lt;em&gt;dar una respuesta&lt;/em&gt; a ese evento.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;div style="text-align: justify;"&gt;La función &lt;code style="white-space: pre;"&gt;OnSelect&lt;/code&gt; bien puede reducirse a dos líneas si es que no requerimos confirmación de borrado, algo como:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;def&lt;/span&gt; OnSelect(event):&lt;br&gt;    event.artist.remove()&lt;br&gt;    fig.canvas.draw()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;El resto de código es para crear un cuadro de diálogo en wxPython que nos pregunta si realmente queremos borrar la línea que hemos seleccionado.&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;br&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Borrar%20lineas%20en%20Matplotlib%20de%20manera%20interactiva/img/img_01.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Podríamos &lt;em&gt;mejorar&lt;/em&gt; un poquito nuestro "demo" si por ejemplo cada vez que seleccionamos una línea esta sea modificada para distinguirse un poco más del resto, por ejemplo modificar su grosor, y en caso de no confirmar su borrado entonces regresar al aspecto original. Agregando algunas líneas nos queda un código más o menos como este:&lt;/div&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# -*- coding: utf-8 -*-&lt;/span&gt;&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; wx&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; matplotlib.pyplot &lt;span class="im"&gt;as&lt;/span&gt; plt&lt;br&gt;&lt;span class="im"&gt;import&lt;/span&gt; numpy &lt;span class="im"&gt;as&lt;/span&gt; np&lt;br&gt;&lt;br&gt;&lt;span class="kw" style="color: #007020; font-weight: bold;"&gt;def&lt;/span&gt; OnSelect(event):&lt;br&gt;    klw &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;&lt;br&gt;    event.artist.set_lw(event.artist.get_lw() &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; klw)&lt;br&gt;    fig.canvas.draw()&lt;br&gt;    app &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.App()&lt;br&gt;    dlg &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; wx.MessageDialog(&lt;span class="va" style="color: #19177c;"&gt;None&lt;/span&gt;, &lt;span class="st" style="color: #4070a0;"&gt;"Desea borrar"&lt;/span&gt;,&lt;br&gt;    &lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;'Matplotlib Demo'&lt;/span&gt;, wx.YES_NO&lt;span class="op" style="color: #666666;"&gt;|&lt;/span&gt;wx.ICON_QUESTION)&lt;br&gt;    &lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;if&lt;/span&gt; dlg.ShowModal() &lt;span class="op" style="color: #666666;"&gt;==&lt;/span&gt; wx.ID_YES:&lt;br&gt;        event.artist.remove()&lt;br&gt;    &lt;span class="cf" style="color: #007020; font-weight: bold;"&gt;else&lt;/span&gt;:&lt;br&gt;        event.artist.set_lw(event.artist.get_lw() &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; klw)&lt;br&gt;    dlg.Destroy()&lt;br&gt;    app.MainLoop()&lt;br&gt;    fig.canvas.draw()&lt;br&gt;&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Definir datos a plotear&lt;/span&gt;&lt;br&gt;X &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; np.random.random((&lt;span class="dv" style="color: #40a070;"&gt;10&lt;/span&gt;,&lt;span class="dv" style="color: #40a070;"&gt;5&lt;/span&gt;))&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Crear figure y axes&lt;/span&gt;&lt;br&gt;fig &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; plt.figure()&lt;br&gt;ax &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.add_subplot(&lt;span class="dv" style="color: #40a070;"&gt;111&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Graficar datos&lt;/span&gt;&lt;br&gt;ax.plot(X, picker&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;&lt;span class="va" style="color: #19177c;"&gt;True&lt;/span&gt;)&lt;br&gt;&lt;span class="co" style="color: #60a0b0; font-style: italic;"&gt;# Conectar evento "pick_event"&lt;/span&gt;&lt;br&gt;pick &lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt; fig.canvas.mpl_connect(&lt;span class="st" style="color: #4070a0;"&gt;"pick_event"&lt;/span&gt;, OnSelect)&lt;br&gt;plt.show()&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;a href="file:///C:/Users/User/Desktop/LABPro/_blogs_/Python%20para%20Ingenieros/Posts/Borrar%20lineas%20en%20Matplotlib%20de%20manera%20interactiva/img/img_02.png"&gt;&lt;/a&gt;&lt;br&gt;&lt;br&gt;&lt;div class="separator" style="clear: both; text-align: center;"&gt;&lt;a href="https://1.bp.blogspot.com/-yqflea3-OII/Vs12TDN5p0I/AAAAAAAABxY/Q6NiQ0rhYms/s1600/img_02.png" style="margin-left: 1em; margin-right: 1em;"&gt;&lt;img border="0" height="267" src="https://1.bp.blogspot.com/-yqflea3-OII/Vs12TDN5p0I/AAAAAAAABxY/Q6NiQ0rhYms/s320/img_02.png" width="320"&gt;&lt;/a&gt;&lt;/div&gt;&lt;br&gt;&lt;br&gt;&lt;div style="text-align: justify;"&gt;Y bueno, con esto finalizamos esta pequeña introducción a las formas interactivas de Matplotlib, desde luego existen muchas posibilidades para implementar, de tal modo que nos quede algo más &lt;em&gt;chulo&lt;/em&gt;.&lt;/div&gt;</description><category>mathjax</category><category>Matplotlib</category><category>wxPython</category><guid>https://numython.github.io/posts/2016/02/borrar-lineas-en-matplotlib-de-manera/</guid><pubDate>Wed, 24 Feb 2016 15:24:00 GMT</pubDate></item><item><title>Una introducción a SymPy</title><link>https://numython.github.io/posts/2016/02/una-introduccion-sympy/</link><dc:creator>Pedro Jorge De Los Santos</dc:creator><description>&lt;p&gt;SymPy es una librería de Python desarrollada para resolver problemas de matemáticas simbólicas. Existen diversos software comerciales que realizan estas tareas: Maple, Mathematica, MATLAB, entre otros, pero requieren una licencia de uso que puede resultar poco accesible en algunos casos. En cambio, SymPy se distribuye bajo licencia BSD, que en resumen permite el uso libre de la misma.&lt;br&gt;&lt;br&gt;&lt;/p&gt;&lt;h3 id="importando-sympy"&gt;Importando SymPy&lt;/h3&gt;Para importar SymPy y disponer de todos los módulos y funciones que le componen puede hacerse de diversas formas:&lt;br&gt;&lt;ol&gt;&lt;li&gt;Forma tradicional&lt;/li&gt;&lt;/ol&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; sympy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Es la manera más habitual, se carga toda la librería y se accede a cada una de las funciones mediante la sintaxis:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; r&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;sympy.funcion(args)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="2"&gt;&lt;li&gt;Importando funciones seleccionadas&lt;/li&gt;&lt;/ol&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol,integrate,sin,cos&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;De este modo se importan solamente las funciones que vayan a utilizarse, es recomendable cuando se utilizará un número reducido de las mismas. Proporciona cierta ventaja dado que para acceder a una función no es necesario anteponer el nombre de la librería (sympy), aunque esto mismo represente una desventaja en aquellos casos en los que existen funciones de diferentes librerías con el mismo nombre.&lt;br&gt;&lt;ol start="3"&gt;&lt;li&gt;Utilizando un alias o seudónimo&lt;/li&gt;&lt;/ol&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;import&lt;/span&gt; sympy &lt;span class="im"&gt;as&lt;/span&gt; sp&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Funciona del mismo modo que para el primer caso, con la diferencia que el usuario puede asignarle un nombre más corto o bien más representativo para hacer las llamadas a funciones.&lt;br&gt;Para los ejemplos que se mostrarán en esta entrada se utilizará la segunda forma.&lt;br&gt;&lt;br&gt;&lt;h3 id="declarando-una-variable-simbólica"&gt;Declarando una variable simbólica&lt;/h3&gt;&lt;br&gt;Para declarar una variable simbólica podemos utilizar la función Symbol, para ello primero importamos la función y posteriormente declaramos una variable simbólica "x":&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;Symbol(&lt;span class="st" style="color: #4070a0;"&gt;'x'&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;br&gt;x&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="dv" style="color: #40a070;"&gt;+2&lt;/span&gt;&lt;br&gt;x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Como puede verse, una vez se ha declarado la variable simbólica podemos utilizarle para formar expresiones algebraicas de todo tipo. Existe una forma más "simple" de declarar una variable simbólica, para ello habrá de importarse del módulo "abc" la letra correspondiente, por ejemplo:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;O bien:&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy.abc &lt;span class="im"&gt;import&lt;/span&gt; x,y,z&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;br&gt;Lo anterior en el caso de que se requieran múltiples variables simbólicas.&lt;br&gt;&lt;br&gt;&lt;h3 id="manipulaciones-algebraicas"&gt;Manipulaciones algebraicas&lt;/h3&gt;&lt;h4 id="factorizar-una-expresión-algebraica."&gt;&lt;br&gt;&lt;/h4&gt;&lt;h4 id="factorizar-una-expresión-algebraica."&gt;Factorizar una expresión algebraica.&lt;/h4&gt;Para factorizar una expresión algebraica podemos utilizar la función factor, por ejemplo suponga que se quiere factorizar la expresión (x^2+2x+1):&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; factor,Symbol&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;Symbol(&lt;span class="st" style="color: #4070a0;"&gt;'x'&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; factor(x&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2+2&lt;/span&gt;&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;x&lt;span class="dv" style="color: #40a070;"&gt;+1&lt;/span&gt;)&lt;br&gt;(x &lt;span class="op" style="color: #666666;"&gt;+&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;1&lt;/span&gt;)&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h4 id="expandir-una-expresión-algebraica"&gt;&lt;br&gt;&lt;/h4&gt;&lt;h4 id="expandir-una-expresión-algebraica"&gt;Expandir una expresión algebraica&lt;/h4&gt;&lt;br&gt;Enseguida se muestra un ejemplo de cómo "expandir" o multiplicar dos expresiones algebraicas.&lt;br&gt;&lt;br&gt;&lt;div class="sourceCode"&gt;&lt;pre class="sourceCode python"&gt;&lt;code class="sourceCode python"&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="im"&gt;from&lt;/span&gt; sympy &lt;span class="im"&gt;import&lt;/span&gt; Symbol,expand&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; x&lt;span class="op" style="color: #666666;"&gt;=&lt;/span&gt;Symbol(&lt;span class="st" style="color: #4070a0;"&gt;'x'&lt;/span&gt;)&lt;br&gt;&lt;span class="op" style="color: #666666;"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; expand((x&lt;span class="dv" style="color: #40a070;"&gt;+2&lt;/span&gt;)&lt;span class="op" style="color: #666666;"&gt;*&lt;/span&gt;(x&lt;span class="dv" style="color: #40a070;"&gt;-3&lt;/span&gt;))&lt;br&gt;x&lt;span class="op" style="color: #666666;"&gt;**&lt;/span&gt;&lt;span class="dv" style="color: #40a070;"&gt;2&lt;/span&gt; &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; x &lt;span class="op" style="color: #666666;"&gt;-&lt;/span&gt; &lt;span class="dv" style="color: #40a070;"&gt;6&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description><category>CAS</category><category>mathjax</category><category>SymPy</category><guid>https://numython.github.io/posts/2016/02/una-introduccion-sympy/</guid><pubDate>Wed, 24 Feb 2016 13:58:00 GMT</pubDate></item></channel></rss>